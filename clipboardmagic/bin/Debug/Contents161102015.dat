C:\xmlsec\libxmlsec-1.2.18.win32\libxmlsec-1.2.18.win32\bin\libxmlsec-openssl.dll

C:\xmlsec\libxmlsec-1.2.18.win32\libxmlsec-1.2.18.win32\bin\libxmlsec-mscrypto.dll

rsakey.pem 

C:\xmlsec\xmlsec1-1.2.20\examples\rsakey.pem

C:\xmlsec\xmlsec1-1.2.20\examples\rsacert.pem

xml_file

C:\Users\502525009\Documents\Visual Studio 2010\Projects\xmlsecTest\Debug\rsacert.pem

C:\Users\502525009\Documents\Visual Studio 2010\Projects\xmlsecTest\Debug\rsakey.pem

C:\Users\502525009\Documents\Visual Studio 2010\Projects\xmlsecTest\Debug\sign3-doc.xml

xmlSecDSigCtxSign(dsigCtx, signNode)

xmlSecDSigCtxSign

xmlSecDSigCtxSign returns -1

xmlDocDumpMemory 

xmlSecDSigCtxSign

/**
 * xmlSecDSigCtxSign:
 * @dsigCtx:            the pointer to <dsig:Signature/> processing context.
 * @tmpl:               the pointer to <dsig:Signature/> node with signature template.
 *
 * Signs the data as described in @tmpl node.
 *
 * Returns: 0 on success or a negative value if an error occurs.
 */
int xmlSecDSigCtxSign(xmlSecDSigCtxPtr dsigCtx, xmlNodePtr tmpl)
{
    int ret;

    xmlSecAssert2(dsigCtx != NULL, -1);
    xmlSecAssert2(dsigCtx->result == NULL, -1);
    xmlSecAssert2(tmpl != NULL, -1);
    xmlSecAssert2(tmpl->doc != NULL, -1);

    /* add ids for Signature nodes */
    dsigCtx->operation  = xmlSecTransformOperationSign;
    dsigCtx->status     = xmlSecDSigStatusUnknown;
    xmlSecAddIDs(tmpl->doc, tmpl, xmlSecDSigIds);

    /* read signature template */
    ret = xmlSecDSigCtxProcessSignatureNode(dsigCtx, tmpl);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecDSigCtxSignatureProcessNode",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }
    xmlSecAssert2(dsigCtx->signMethod != NULL, -1);
    xmlSecAssert2(dsigCtx->signValueNode != NULL, -1);

    /* references processing might change the status */
    if(dsigCtx->status != xmlSecDSigStatusUnknown) {
        return(0);
    }

    /* check what we've got */
    dsigCtx->result = dsigCtx->transformCtx.result;
    if((dsigCtx->result == NULL) || (xmlSecBufferGetData(dsigCtx->result) == NULL)) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    NULL,
                    XMLSEC_ERRORS_R_INVALID_RESULT,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }

    /* write signed data to xml */
    xmlNodeSetContentLen(dsigCtx->signValueNode,
                            xmlSecBufferGetData(dsigCtx->result),
                            xmlSecBufferGetSize(dsigCtx->result));

    /* set success status and we are done */
    dsigCtx->status = xmlSecDSigStatusSucceeded;
    return(0);

xmlSecError

void
xmlSecError(const char* file, int line, const char* func,
            const char* errorObject, const char* errorSubject,
            int reason, const char* msg, ...) {

xmlSecAssert2

xmlSecDSigCtxProcessSignatureNode

/**
 * xmlSecDSigCtxProcessSignatureNode:
 *
 * The Signature  element (http://www.w3.org/TR/xmldsig-core/#sec-Signature)
 *
 * The Signature element is the root element of an XML Signature.
 * Implementation MUST generate laxly schema valid [XML-schema] Signature
 * elements as specified by the following schema:
 * The way in which the SignedInfo element is presented to the
 * canonicalization method is dependent on that method. The following
 * applies to algorithms which process XML as nodes or characters:
 *
 *  - XML based canonicalization implementations MUST be provided with
 *  a [XPath] node-set originally formed from the document containing
 *  the SignedInfo and currently indicating the SignedInfo, its descendants,
 *  and the attribute and namespace nodes of SignedInfo and its descendant
 *  elements.
 *
 *  - Text based canonicalization algorithms (such as CRLF and charset
 *  normalization) should be provided with the UTF-8 octets that represent
 *  the well-formed SignedInfo element, from the first character to the
 *  last character of the XML representation, inclusive. This includes
 *  the entire text of the start and end tags of the SignedInfo element
 *  as well as all descendant markup and character data (i.e., the text)
 *  between those tags. Use of text based canonicalization of SignedInfo
 *  is NOT RECOMMENDED.
 *
 *  =================================
 *  we do not support any non XML based C14N
 *
 * Schema Definition:
 *
 *  <element name="Signature" type="ds:SignatureType"/>
 *  <complexType name="SignatureType">
 *  <sequence>
 *     <element ref="ds:SignedInfo"/>
 *     <element ref="ds:SignatureValue"/>
 *     <element ref="ds:KeyInfo" minOccurs="0"/>
 *     <element ref="ds:Object" minOccurs="0" maxOccurs="unbounded"/>
 *     </sequence> <attribute name="Id" type="ID" use="optional"/>
 *  </complexType>
 *
 * DTD:
 *
 *  <!ELEMENT Signature (SignedInfo, SignatureValue, KeyInfo?, Object*)  >
 *  <!ATTLIST Signature
 *      xmlns   CDATA   #FIXED 'http://www.w3.org/2000/09/xmldsig#'
 *      Id      ID  #IMPLIED >
 *
 */
static int xmlSecDSigCtxProcessSignatureNode(xmlSecDSigCtxPtr dsigCtx, xmlNodePtr node) {
    xmlSecTransformDataType firstType;
    xmlNodePtr signedInfoNode = NULL;
    xmlNodePtr keyInfoNode = NULL;
    xmlNodePtr cur;
    int ret;

    xmlSecAssert2(dsigCtx != NULL, -1);
    xmlSecAssert2((dsigCtx->operation == xmlSecTransformOperationSign) || (dsigCtx->operation == xmlSecTransformOperationVerify), -1);
    xmlSecAssert2(dsigCtx->status == xmlSecDSigStatusUnknown, -1);
    xmlSecAssert2(dsigCtx->signValueNode == NULL, -1);
    xmlSecAssert2(dsigCtx->signMethod == NULL, -1);
    xmlSecAssert2(dsigCtx->c14nMethod == NULL, -1);
    xmlSecAssert2(node != NULL, -1);

    if(!xmlSecCheckNodeName(node, xmlSecNodeSignature, xmlSecDSigNs)) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    xmlSecErrorsSafeString(xmlSecNodeGetName(node)),
                    XMLSEC_ERRORS_R_INVALID_NODE,
                    "expected=%s",
                    xmlSecErrorsSafeString(xmlSecNodeSignature));
        return(-1);
    }

    /* read node data */
    xmlSecAssert2(dsigCtx->id == NULL, -1);
    dsigCtx->id = xmlGetProp(node, xmlSecAttrId);

    /* first node is required SignedInfo */
    cur = xmlSecGetNextElementNode(node->children);
    if((cur == NULL) || (!xmlSecCheckNodeName(cur, xmlSecNodeSignedInfo, xmlSecDSigNs))) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    xmlSecErrorsSafeString(xmlSecNodeGetName(cur)),
                    XMLSEC_ERRORS_R_INVALID_NODE,
                    "expected=%s",
                    xmlSecErrorsSafeString(xmlSecNodeSignedInfo));
        return(-1);
    }
    signedInfoNode = cur;
    cur = xmlSecGetNextElementNode(cur->next);

    /* next node is required SignatureValue */
    if((cur == NULL) || (!xmlSecCheckNodeName(cur, xmlSecNodeSignatureValue, xmlSecDSigNs))) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    xmlSecErrorsSafeString(xmlSecNodeGetName(cur)),
                    XMLSEC_ERRORS_R_INVALID_NODE,
                    "expected=%s",
                    xmlSecErrorsSafeString(xmlSecNodeSignatureValue));
        return(-1);
    }
    dsigCtx->signValueNode = cur;
    cur = xmlSecGetNextElementNode(cur->next);

    /* next node is optional KeyInfo */
    if((cur != NULL) && (xmlSecCheckNodeName(cur, xmlSecNodeKeyInfo, xmlSecDSigNs))) {
        keyInfoNode = cur;
        cur = xmlSecGetNextElementNode(cur->next);
    } else {
        keyInfoNode = NULL;
    }

    /* next nodes are optional Object nodes */
    while((cur != NULL) && (xmlSecCheckNodeName(cur, xmlSecNodeObject, xmlSecDSigNs))) {
        /* read manifests from objects */
        if((dsigCtx->flags & XMLSEC_DSIG_FLAGS_IGNORE_MANIFESTS) == 0) {
            ret = xmlSecDSigCtxProcessObjectNode(dsigCtx, cur);
            if(ret < 0) {
                xmlSecError(XMLSEC_ERRORS_HERE,
                            NULL,
                            "xmlSecDSigCtxProcessObjectNode",
                            XMLSEC_ERRORS_R_XMLSEC_FAILED,
                            XMLSEC_ERRORS_NO_MESSAGE);
                return(-1);
            }
        }
        cur = xmlSecGetNextElementNode(cur->next);
    }

    /* if there is something left than it's an error */
    if(cur != NULL) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    xmlSecErrorsSafeString(xmlSecNodeGetName(cur)),
                    XMLSEC_ERRORS_R_UNEXPECTED_NODE,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }

    /* now validated all the references and prepare transform */
    ret = xmlSecDSigCtxProcessSignedInfoNode(dsigCtx, signedInfoNode);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecDSigCtxProcessSignedInfoNode",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }
    /* references processing might change the status */
    if(dsigCtx->status != xmlSecDSigStatusUnknown) {
        return(0);
    }

    /* as the result, we should have sign and c14n methods set */
    xmlSecAssert2(dsigCtx->signMethod != NULL, -1);
    xmlSecAssert2(dsigCtx->c14nMethod != NULL, -1);

    ret = xmlSecDSigCtxProcessKeyInfoNode(dsigCtx, keyInfoNode);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecDSigCtxProcessKeyInfoNode",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }
    /* as the result, we should have a key */
    xmlSecAssert2(dsigCtx->signKey != NULL, -1);

    /* if we need to write result to xml node then we need base64 encode result */
    if(dsigCtx->operation == xmlSecTransformOperationSign) {
        xmlSecTransformPtr base64Encode;

        /* we need to add base64 encode transform */
        base64Encode = xmlSecTransformCtxCreateAndAppend(&(dsigCtx->transformCtx),
                                                         xmlSecTransformBase64Id);
        if(base64Encode == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxCreateAndAppend",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }
        base64Encode->operation = xmlSecTransformOperationEncode;
    }

    firstType = xmlSecTransformGetDataType(dsigCtx->transformCtx.first,
                                           xmlSecTransformModePush,
                                           &(dsigCtx->transformCtx));
    if((firstType & xmlSecTransformDataTypeXml) != 0) {
        xmlSecNodeSetPtr nodeset = NULL;

        xmlSecAssert2(signedInfoNode != NULL, -1);
        nodeset = xmlSecNodeSetGetChildren(signedInfoNode->doc, signedInfoNode, 1, 0);
        if(nodeset == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecNodeSetGetChildren",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "node=%s",
                        xmlSecErrorsSafeString(xmlSecNodeGetName(signedInfoNode)));
            return(-1);
        }

        /* calculate the signature */
        ret = xmlSecTransformCtxXmlExecute(&(dsigCtx->transformCtx), nodeset);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxXmlExecute",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            xmlSecNodeSetDestroy(nodeset);
            return(-1);
        }
        xmlSecNodeSetDestroy(nodeset);
    } else {
        /* TODO */
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "the binary c14n transforms are not supported yet",
                    XMLSEC_ERRORS_R_NOT_IMPLEMENTED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }
    return(0);
}


xmlSecError

void
xmlSecError(const char* file, int line, const char* func,
            const char* errorObject, const char* errorSubject,
            int reason, const char* msg, ...) {

XMLSEC_ERRORS_HERE

#define XMLSEC_ERRORS_HERE                      __FILE__,__LINE__,__XMLSEC_FUNCTION__

xmlSecDSigCtxProcessObjectNode

/**
 * xmlSecDSigCtxProcessObjectNode:
 *
 * The Object Element (http://www.w3.org/TR/xmldsig-core/#sec-Object)
 *
 * Object is an optional element that may occur one or more times. When
 * present, this element may contain any data. The Object element may include
 * optional MIME type, ID, and encoding attributes.
 *
 * Schema Definition:
 *
 * <element name="Object" type="ds:ObjectType"/>
 * <complexType name="ObjectType" mixed="true">
 *   <sequence minOccurs="0" maxOccurs="unbounded">
 *     <any namespace="##any" processContents="lax"/>
 *   </sequence>
 *   <attribute name="Id" type="ID" use="optional"/>
 *   <attribute name="MimeType" type="string" use="optional"/>
 *   <attribute name="Encoding" type="anyURI" use="optional"/>
 * </complexType>
 *
 * DTD:
 *
 * <!ELEMENT Object (#PCDATA|Signature|SignatureProperties|Manifest %Object.ANY;)* >
 * <!ATTLIST Object  Id  ID  #IMPLIED
 *                   MimeType    CDATA   #IMPLIED
 *                   Encoding    CDATA   #IMPLIED >
 */
static int
xmlSecDSigCtxProcessObjectNode(xmlSecDSigCtxPtr dsigCtx, xmlNodePtr node) {
    xmlNodePtr cur;
    int ret;

    xmlSecAssert2(dsigCtx != NULL, -1);
    xmlSecAssert2(dsigCtx->status == xmlSecDSigStatusUnknown, -1);
    xmlSecAssert2(node != NULL, -1);

    /* we care about Manifest nodes only; ignore everything else */
    cur = xmlSecGetNextElementNode(node->children);
    while(cur != NULL) {
        if(xmlSecCheckNodeName(cur, xmlSecNodeManifest, xmlSecDSigNs)) {
            ret = xmlSecDSigCtxProcessManifestNode(dsigCtx, cur);
            if(ret < 0){
                xmlSecError(XMLSEC_ERRORS_HERE,
                            NULL,
                            "xmlSecDSigCtxProcessManifestNode",
                            XMLSEC_ERRORS_R_XMLSEC_FAILED,
                            XMLSEC_ERRORS_NO_MESSAGE);
                return(-1);
            }
        }
        cur = xmlSecGetNextElementNode(cur->next);
    }
    return(0);
}

xmlSecDSigCtxProcessSignedInfoNode

/**
 * xmlSecDSigCtxProcessSignedInfoNode:
 *
 * The SignedInfo Element (http://www.w3.org/TR/xmldsig-core/#sec-SignedInfo)
 *
 * The structure of SignedInfo includes the canonicalization algorithm,
 * a result algorithm, and one or more references. The SignedInfo element
 * may contain an optional ID attribute that will allow it to be referenced by
 * other signatures and objects.
 *
 * SignedInfo does not include explicit result or digest properties (such as
 * calculation time, cryptographic device serial number, etc.). If an
 * application needs to associate properties with the result or digest,
 * it may include such information in a SignatureProperties element within
 * an Object element.
 *
 * Schema Definition:
 *
 *  <element name="SignedInfo" type="ds:SignedInfoType"/>
 *  <complexType name="SignedInfoType">
 *    <sequence>
 *      <element ref="ds:CanonicalizationMethod"/>
 *      <element ref="ds:SignatureMethod"/>
 *      <element ref="ds:Reference" maxOccurs="unbounded"/>
 *    </sequence>
 *    <attribute name="Id" type="ID" use="optional"/>
 *  </complexType>
 *
 * DTD:
 *
 *  <!ELEMENT SignedInfo (CanonicalizationMethod, SignatureMethod,  Reference+) >
 *  <!ATTLIST SignedInfo  Id   ID      #IMPLIED>
 *
 */
static int
xmlSecDSigCtxProcessSignedInfoNode(xmlSecDSigCtxPtr dsigCtx, xmlNodePtr node) {
    xmlSecDSigReferenceCtxPtr dsigRefCtx;
    xmlNodePtr cur;
    int ret;

    xmlSecAssert2(dsigCtx != NULL, -1);
    xmlSecAssert2(dsigCtx->status == xmlSecDSigStatusUnknown, -1);
    xmlSecAssert2(dsigCtx->signMethod == NULL, -1);
    xmlSecAssert2(dsigCtx->c14nMethod == NULL, -1);
    xmlSecAssert2((dsigCtx->operation == xmlSecTransformOperationSign) || (dsigCtx->operation == xmlSecTransformOperationVerify), -1);
    xmlSecAssert2(xmlSecPtrListGetSize(&(dsigCtx->signedInfoReferences)) == 0, -1);
    xmlSecAssert2(node != NULL, -1);

    /* first node is required CanonicalizationMethod. */
    cur = xmlSecGetNextElementNode(node->children);
    if((cur != NULL) && (xmlSecCheckNodeName(cur, xmlSecNodeCanonicalizationMethod, xmlSecDSigNs))) {
        dsigCtx->c14nMethod = xmlSecTransformCtxNodeRead(&(dsigCtx->transformCtx),
                                        cur, xmlSecTransformUsageC14NMethod);
        if(dsigCtx->c14nMethod == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxNodeRead",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "node=%s",
                        xmlSecErrorsSafeString(xmlSecNodeGetName(cur)));
            return(-1);
        }
    } else if(dsigCtx->defC14NMethodId != xmlSecTransformIdUnknown) {
        /* the dsig spec does require CanonicalizationMethod node
         * to be present but in some case it application might decide to
         * minimize traffic */
        dsigCtx->c14nMethod = xmlSecTransformCtxCreateAndAppend(&(dsigCtx->transformCtx),
                                                              dsigCtx->defC14NMethodId);
        if(dsigCtx->c14nMethod == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxAppend",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }
    } else {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "CanonicalizationMethod",
                    XMLSEC_ERRORS_R_INVALID_NODE,
                    "expected=%s",
                    xmlSecErrorsSafeString(xmlSecNodeCanonicalizationMethod));
        return(-1);
    }

    /* insert membuf if requested */
    if((dsigCtx->flags & XMLSEC_DSIG_FLAGS_STORE_SIGNATURE) != 0) {
        xmlSecAssert2(dsigCtx->preSignMemBufMethod == NULL, -1);
        dsigCtx->preSignMemBufMethod = xmlSecTransformCtxCreateAndAppend(&(dsigCtx->transformCtx),
                                                xmlSecTransformMemBufId);
        if(dsigCtx->preSignMemBufMethod == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxCreateAndAppend",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "transform=%s",
                        xmlSecErrorsSafeString(xmlSecTransformKlassGetName(xmlSecTransformMemBufId)));
        }
    }

    /* next node is required SignatureMethod. */
    cur = xmlSecGetNextElementNode( ((cur != NULL) ? cur->next : node->children) );
    if((cur != NULL) && (xmlSecCheckNodeName(cur, xmlSecNodeSignatureMethod, xmlSecDSigNs))) {
        dsigCtx->signMethod = xmlSecTransformCtxNodeRead(&(dsigCtx->transformCtx),
                                        cur, xmlSecTransformUsageSignatureMethod);
        if(dsigCtx->signMethod == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxNodeRead",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "node=%s",
                        xmlSecErrorsSafeString(xmlSecNodeGetName(cur)));
            return(-1);
        }
    } else if(dsigCtx->defSignMethodId != xmlSecTransformIdUnknown) {
        /* the dsig spec does require SignatureMethod node
         * to be present but in some case it application might decide to
         * minimize traffic */
        dsigCtx->signMethod = xmlSecTransformCtxCreateAndAppend(&(dsigCtx->transformCtx),
                                                              dsigCtx->defSignMethodId);
        if(dsigCtx->signMethod == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxAppend",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }
    } else {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    xmlSecErrorsSafeString(xmlSecNodeGetName(cur)),
                    XMLSEC_ERRORS_R_INVALID_NODE,
                    "expected=%s",
                    xmlSecErrorsSafeString(xmlSecNodeSignatureMethod));
        return(-1);
    }
    dsigCtx->signMethod->operation = dsigCtx->operation;

    /* calculate references */
    cur = xmlSecGetNextElementNode(cur->next);
    while((cur != NULL) && (xmlSecCheckNodeName(cur, xmlSecNodeReference, xmlSecDSigNs))) {
        /* create reference */
        dsigRefCtx = xmlSecDSigReferenceCtxCreate(dsigCtx, xmlSecDSigReferenceOriginSignedInfo);
        if(dsigRefCtx == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecDSigReferenceCtxCreate",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }

        /* add to the list */
        ret = xmlSecPtrListAdd(&(dsigCtx->signedInfoReferences), dsigRefCtx);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecPtrListAdd",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            xmlSecDSigReferenceCtxDestroy(dsigRefCtx);
            return(-1);
        }

        /* process */
        ret = xmlSecDSigReferenceCtxProcessNode(dsigRefCtx, cur);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecDSigReferenceCtxProcessNode",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "node=%s",
                        xmlSecErrorsSafeString(xmlSecNodeGetName(cur)));
            return(-1);
        }

        /* bail out if next Reference processing failed */
        if(dsigRefCtx->status != xmlSecDSigStatusSucceeded) {
            dsigCtx->status = xmlSecDSigStatusInvalid;
            return(0);
        }
        cur = xmlSecGetNextElementNode(cur->next);
    }

    /* check that we have at least one Reference */
    if(xmlSecPtrListGetSize(&(dsigCtx->signedInfoReferences)) == 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    NULL,
                    XMLSEC_ERRORS_R_DSIG_NO_REFERENCES,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }

    /* if there is something left than it's an error */
    if(cur != NULL) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    xmlSecErrorsSafeString(xmlSecNodeGetName(cur)),
                    XMLSEC_ERRORS_R_UNEXPECTED_NODE,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }
    return(0);
}


xmlSecTransformMemBufId

_xmlSecTransformKlass

xmlSecTransformId

xmlSecTransformMemBufId

xmlSecDSigCtxProcessManifestNode


/**
 * xmlSecDSigCtxProcessManifestNode:
 *
 * The Manifest  Element (http://www.w3.org/TR/xmldsig-core/#sec-Manifest)
 *
 * The Manifest element provides a list of References. The difference from
 * the list in SignedInfo is that it is application defined which, if any, of
 * the digests are actually checked against the objects referenced and what to
 * do if the object is inaccessible or the digest compare fails. If a Manifest
 * is pointed to from SignedInfo, the digest over the Manifest itself will be
 * checked by the core result validation behavior. The digests within such
 * a Manifest are checked at the application's discretion. If a Manifest is
 * referenced from another Manifest, even the overall digest of this two level
 * deep Manifest might not be checked.
 *
 * Schema Definition:
 *
 * <element name="Manifest" type="ds:ManifestType"/>
 * <complexType name="ManifestType">
 *   <sequence>
 *     <element ref="ds:Reference" maxOccurs="unbounded"/>
 *   </sequence>
 *   <attribute name="Id" type="ID" use="optional"/>
 *  </complexType>
 *
 * DTD:
 *
 * <!ELEMENT Manifest (Reference+)  >
 * <!ATTLIST Manifest Id ID  #IMPLIED >
 */
static int
xmlSecDSigCtxProcessManifestNode(xmlSecDSigCtxPtr dsigCtx, xmlNodePtr node) {
    xmlSecDSigReferenceCtxPtr dsigRefCtx;
    xmlNodePtr cur;
    int ret;

    xmlSecAssert2(dsigCtx != NULL, -1);
    xmlSecAssert2(dsigCtx->status == xmlSecDSigStatusUnknown, -1);
    xmlSecAssert2(node != NULL, -1);

    /* calculate references */
    cur = xmlSecGetNextElementNode(node->children);
    while((cur != NULL) && (xmlSecCheckNodeName(cur, xmlSecNodeReference, xmlSecDSigNs))) {
        /* create reference */
        dsigRefCtx = xmlSecDSigReferenceCtxCreate(dsigCtx, xmlSecDSigReferenceOriginManifest);
        if(dsigRefCtx == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecDSigReferenceCtxCreate",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }

        /* add to the list */
        ret = xmlSecPtrListAdd(&(dsigCtx->manifestReferences), dsigRefCtx);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecPtrListAdd",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            xmlSecDSigReferenceCtxDestroy(dsigRefCtx);
            return(-1);
        }

        /* process */
        ret = xmlSecDSigReferenceCtxProcessNode(dsigRefCtx, cur);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecDSigReferenceCtxProcessNode",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "node=%s",
                        xmlSecErrorsSafeString(xmlSecNodeGetName(cur)));
            return(-1);
        }

        /* we don;t care if Reference processing failed because
         * it's Manifest node */
        cur = xmlSecGetNextElementNode(cur->next);
    }

    /* we should have nothing else here */
    if(cur != NULL) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    xmlSecErrorsSafeString(xmlSecNodeGetName(cur)),
                    XMLSEC_ERRORS_R_UNEXPECTED_NODE,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }
    return(0);
}


xmlSecDSigCtxProcessKeyInfoNode

static int
xmlSecDSigCtxProcessKeyInfoNode(xmlSecDSigCtxPtr dsigCtx, xmlNodePtr node) {
    int ret;

    xmlSecAssert2(dsigCtx != NULL, -1);
    xmlSecAssert2(dsigCtx->signMethod != NULL, -1);

    /* set key requirements */
    ret = xmlSecTransformSetKeyReq(dsigCtx->signMethod, &(dsigCtx->keyInfoReadCtx.keyReq));
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformSetKeyReq",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "transform=%s",
                    xmlSecErrorsSafeString(xmlSecTransformGetName(dsigCtx->signMethod)));
        return(-1);
    }

    /* ignore <dsig:KeyInfo /> if there is the key is already set */
    /* todo: throw an error if key is set and node != NULL? */
    if((dsigCtx->signKey == NULL) && (dsigCtx->keyInfoReadCtx.keysMngr != NULL)
                        && (dsigCtx->keyInfoReadCtx.keysMngr->getKey != NULL)) {
        dsigCtx->signKey = (dsigCtx->keyInfoReadCtx.keysMngr->getKey)(node, &(dsigCtx->keyInfoReadCtx));
    }

    /* check that we have exactly what we want */
    if((dsigCtx->signKey == NULL) || (!xmlSecKeyMatch(dsigCtx->signKey, NULL, &(dsigCtx->keyInfoReadCtx.keyReq)))) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    NULL,
                    XMLSEC_ERRORS_R_KEY_NOT_FOUND,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }

    /* set the key to the transform */
    ret = xmlSecTransformSetKey(dsigCtx->signMethod, dsigCtx->signKey);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformSetKey",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "transform=%s",
                    xmlSecErrorsSafeString(xmlSecTransformGetName(dsigCtx->signMethod)));
        return(-1);
    }

    /* if we are signing document, update <dsig:KeyInfo/> node */
    if((node != NULL) && (dsigCtx->operation == xmlSecTransformOperationSign)) {
        ret = xmlSecKeyInfoNodeWrite(node, dsigCtx->signKey, &(dsigCtx->keyInfoWriteCtx));
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecKeyInfoNodeWrite",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }
    }

    return(0);
}

xmlSecDSigIds

/* The ID attribute in XMLDSig is 'Id' */
static const xmlChar*           xmlSecDSigIds[] = { xmlSecAttrId, NULL };

signMethod

xmlSecDSigCtxPtr

xmlSecDSigCtxCreate

/**
 * xmlSecDSigCtxCreate:
 * @keysMngr:           the pointer to keys manager.
 *
 * Creates <dsig:Signature/> element processing context.
 * The caller is responsible for destroying returned object by calling
 * #xmlSecDSigCtxDestroy function.
 *
 * Returns: pointer to newly allocated context object or NULL if an error
 * occurs.
 */
xmlSecDSigCtxPtr
xmlSecDSigCtxCreate(xmlSecKeysMngrPtr keysMngr) {
    xmlSecDSigCtxPtr dsigCtx;
    int ret;

    dsigCtx = (xmlSecDSigCtxPtr) xmlMalloc(sizeof(xmlSecDSigCtx));
    if(dsigCtx == NULL) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    NULL,
                    XMLSEC_ERRORS_R_MALLOC_FAILED,
                    "sizeof(xmlSecDSigCtx)=%d",
                    sizeof(xmlSecDSigCtx));
        return(NULL);
    }

    ret = xmlSecDSigCtxInitialize(dsigCtx, keysMngr);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecDSigCtxInitialize",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        xmlSecDSigCtxDestroy(dsigCtx);
        return(NULL);
    }
    return(dsigCtx);
}

xmlSecDSigCtxCreateD

xmlSecDSigCtxInitialize

/**
 * xmlSecDSigCtxInitialize:
 * @dsigCtx:            the pointer to <dsig:Signature/> processing context.
 * @keysMngr:           the pointer to keys manager.
 *
 * Initializes <dsig:Signature/> element processing context.
 * The caller is responsible for cleaning up returned object by calling
 * #xmlSecDSigCtxFinalize function.
 *
 * Returns: 0 on success or a negative value if an error occurs.
 */
int
xmlSecDSigCtxInitialize(xmlSecDSigCtxPtr dsigCtx, xmlSecKeysMngrPtr keysMngr) {
    int ret;

    xmlSecAssert2(dsigCtx != NULL, -1);

    memset(dsigCtx, 0, sizeof(xmlSecDSigCtx));

    /* initialize key info */
    ret = xmlSecKeyInfoCtxInitialize(&(dsigCtx->keyInfoReadCtx), keysMngr);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecKeyInfoCtxInitialize",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }
    dsigCtx->keyInfoReadCtx.mode = xmlSecKeyInfoModeRead;

    ret = xmlSecKeyInfoCtxInitialize(&(dsigCtx->keyInfoWriteCtx), keysMngr);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecKeyInfoCtxInitialize",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }
    dsigCtx->keyInfoWriteCtx.mode = xmlSecKeyInfoModeWrite;
    /* it's not wise to write private key :) */
    dsigCtx->keyInfoWriteCtx.keyReq.keyType = xmlSecKeyDataTypePublic;

    /* initializes transforms dsigCtx */
    ret = xmlSecTransformCtxInitialize(&(dsigCtx->transformCtx));
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCtxInitialize",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }

    /* references lists from SignedInfo and Manifest elements */
    xmlSecPtrListInitialize(&(dsigCtx->signedInfoReferences),
                            xmlSecDSigReferenceCtxListId);
    xmlSecPtrListInitialize(&(dsigCtx->manifestReferences),
                            xmlSecDSigReferenceCtxListId);

    dsigCtx->enabledReferenceUris = xmlSecTransformUriTypeAny;
    return(0);
}


xmlSecDSigCtxInitialize

xmlGetProp

xmlSecDSigReferenceCtxCreate

/**************************************************************************
 *
 * xmlSecDSigReferenceCtx
 *
 *************************************************************************/
/**
 * xmlSecDSigReferenceCtxCreate:
 * @dsigCtx:            the pointer to parent <dsig:Signature/> node processing context.
 * @origin:             the reference origin (<dsig:SignedInfo/> or <dsig:Manifest/> node).
 *
 * Creates new <dsig:Reference/> element processing context. Caller is responsible
 * for destroying the returned context by calling #xmlSecDSigReferenceCtxDestroy
 * function.
 *
 * Returns: pointer to newly created context or NULL if an error occurs.
 */
xmlSecDSigReferenceCtxPtr
xmlSecDSigReferenceCtxCreate(xmlSecDSigCtxPtr dsigCtx, xmlSecDSigReferenceOrigin origin) {
    xmlSecDSigReferenceCtxPtr dsigRefCtx;
    int ret;

    xmlSecAssert2(dsigCtx != NULL, NULL);

    dsigRefCtx = (xmlSecDSigReferenceCtxPtr) xmlMalloc(sizeof(xmlSecDSigReferenceCtx));
    if(dsigRefCtx == NULL) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    NULL,
                    XMLSEC_ERRORS_R_MALLOC_FAILED,
                    "sizeof(xmlSecDSigReferenceCtx)=%d",
                    sizeof(xmlSecDSigReferenceCtx));
        return(NULL);
    }

    ret = xmlSecDSigReferenceCtxInitialize(dsigRefCtx, dsigCtx, origin);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecDSigReferenceCtxInitialize",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        xmlSecDSigReferenceCtxDestroy(dsigRefCtx);
        return(NULL);
    }
    return(dsigRefCtx);
}


xmlSecDSigReferenceCtxCreate

xmlSecDSigReferenceCtxInitialize

/**
 * xmlSecDSigReferenceCtxInitialize:
 * @dsigRefCtx:         the pointer to <dsig:Reference/> element processing context.
 * @dsigCtx:            the pointer to parent <dsig:Signature/> node processing context.
 * @origin:             the reference origin (<dsig:SignedInfo/> or <dsig:Manifest/> node).
 *
 * Initializes new <dsig:Reference/> element processing context. Caller is responsible
 * for cleaning up the returned context by calling #xmlSecDSigReferenceCtxFinalize
 * function.
 *
 * Returns: 0 on succes or aa negative value otherwise.
 */
int
xmlSecDSigReferenceCtxInitialize(xmlSecDSigReferenceCtxPtr dsigRefCtx, xmlSecDSigCtxPtr dsigCtx,
                                xmlSecDSigReferenceOrigin origin) {
    int ret;

    xmlSecAssert2(dsigCtx != NULL, -1);
    xmlSecAssert2(dsigRefCtx != NULL, -1);

    memset(dsigRefCtx, 0, sizeof(xmlSecDSigReferenceCtx));

    dsigRefCtx->dsigCtx = dsigCtx;
    dsigRefCtx->origin = origin;

    /* initializes transforms dsigRefCtx */
    ret = xmlSecTransformCtxInitialize(&(dsigRefCtx->transformCtx));
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCtxInitialize",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }

    /* copy enabled transforms */
    if(dsigCtx->enabledReferenceTransforms != NULL) {
        ret = xmlSecPtrListCopy(&(dsigRefCtx->transformCtx.enabledTransforms),
                                     dsigCtx->enabledReferenceTransforms);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecPtrListCopy",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }
    }
    dsigRefCtx->transformCtx.preExecCallback = dsigCtx->referencePreExecuteCallback;
    dsigRefCtx->transformCtx.enabledUris = dsigCtx->enabledReferenceUris;

    if((dsigCtx->flags & XMLSEC_DSIG_FLAGS_USE_VISA3D_HACK) != 0) {
        dsigRefCtx->transformCtx.flags |= XMLSEC_TRANSFORMCTX_FLAGS_USE_VISA3D_HACK;
    }
    return(0);
}


xmlSecDSigReferenceCtxInitialize

xmlSecDSigReferenceCtxProcessNode

/**
 * xmlSecDSigReferenceCtxProcessNode:
 * @dsigRefCtx:         the pointer to <dsig:Reference/> element processing context.
 * @node:               the pointer to <dsig:Reference/> node.

 * The Reference Element (http://www.w3.org/TR/xmldsig-core/#sec-Reference)
 *
 * Reference is an element that may occur one or more times. It specifies
 * a digest algorithm and digest value, and optionally an identifier of the
 * object being signed, the type of the object, and/or a list of transforms
 * to be applied prior to digesting. The identification (URI) and transforms
 * describe how the digested content (i.e., the input to the digest method)
 * was created. The Type attribute facilitates the processing of referenced
 * data. For example, while this specification makes no requirements over
 * external data, an application may wish to signal that the referent is a
 * Manifest. An optional ID attribute permits a Reference to be referenced
 * from elsewhere.
 *
 * Returns: 0 on succes or aa negative value otherwise.
 */
int
xmlSecDSigReferenceCtxProcessNode(xmlSecDSigReferenceCtxPtr dsigRefCtx, xmlNodePtr node) {
    xmlSecTransformCtxPtr transformCtx;
    xmlNodePtr digestValueNode;
    xmlNodePtr cur;
    int ret;

    xmlSecAssert2(dsigRefCtx != NULL, -1);
    xmlSecAssert2(dsigRefCtx->dsigCtx != NULL, -1);
    xmlSecAssert2(dsigRefCtx->digestMethod == NULL, -1);
    xmlSecAssert2(dsigRefCtx->digestMethod == NULL, -1);
    xmlSecAssert2(dsigRefCtx->preDigestMemBufMethod == NULL, -1);
    xmlSecAssert2(node != NULL, -1);
    xmlSecAssert2(node->doc != NULL, -1);

    transformCtx = &(dsigRefCtx->transformCtx);

    /* read attributes first */
    dsigRefCtx->uri = xmlGetProp(node, xmlSecAttrURI);
    dsigRefCtx->id  = xmlGetProp(node, xmlSecAttrId);
    dsigRefCtx->type= xmlGetProp(node, xmlSecAttrType);

    /* set start URI (and check that it is enabled!) */
    ret = xmlSecTransformCtxSetUri(transformCtx, dsigRefCtx->uri, node);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCtxSetUri",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "uri=%s",
                    xmlSecErrorsSafeString(dsigRefCtx->uri));
        return(-1);
    }

    /* first is optional Transforms node */
    cur  = xmlSecGetNextElementNode(node->children);
    if((cur != NULL) && (xmlSecCheckNodeName(cur, xmlSecNodeTransforms, xmlSecDSigNs))) {
        ret = xmlSecTransformCtxNodesListRead(transformCtx,
                                        cur, xmlSecTransformUsageDSigTransform);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxNodesListRead",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "node=%s",
                        xmlSecErrorsSafeString(xmlSecNodeGetName(cur)));
            return(-1);
        }

        cur = xmlSecGetNextElementNode(cur->next);
    }

    /* insert membuf if requested */
    if(((dsigRefCtx->origin == xmlSecDSigReferenceOriginSignedInfo) &&
        ((dsigRefCtx->dsigCtx->flags & XMLSEC_DSIG_FLAGS_STORE_SIGNEDINFO_REFERENCES) != 0)) ||
       ((dsigRefCtx->origin == xmlSecDSigReferenceOriginManifest) &&
        ((dsigRefCtx->dsigCtx->flags & XMLSEC_DSIG_FLAGS_STORE_MANIFEST_REFERENCES) != 0))) {

        xmlSecAssert2(dsigRefCtx->preDigestMemBufMethod == NULL, -1);
        dsigRefCtx->preDigestMemBufMethod = xmlSecTransformCtxCreateAndAppend(
                                                transformCtx,
                                                xmlSecTransformMemBufId);
        if(dsigRefCtx->preDigestMemBufMethod == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxCreateAndAppend",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "transform=%s",
                        xmlSecErrorsSafeString(xmlSecTransformKlassGetName(xmlSecTransformMemBufId)));
            return(-1);
        }
    }

    /* next node is required DigestMethod. */
    if((cur != NULL) && (xmlSecCheckNodeName(cur, xmlSecNodeDigestMethod, xmlSecDSigNs))) {
        dsigRefCtx->digestMethod = xmlSecTransformCtxNodeRead(&(dsigRefCtx->transformCtx),
                                        cur, xmlSecTransformUsageDigestMethod);
        if(dsigRefCtx->digestMethod == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxNodeRead",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "node=%s",
                        xmlSecErrorsSafeString(xmlSecNodeGetName(cur)));
            return(-1);
        }

        cur = xmlSecGetNextElementNode(cur->next);
    } else if(dsigRefCtx->dsigCtx->defSignMethodId != xmlSecTransformIdUnknown) {
        /* the dsig spec does require DigestMethod node
         * to be present but in some case it application might decide to
         * minimize traffic */
        dsigRefCtx->digestMethod = xmlSecTransformCtxCreateAndAppend(&(dsigRefCtx->transformCtx),
                                                              dsigRefCtx->dsigCtx->defSignMethodId);
        if(dsigRefCtx->digestMethod == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxAppend",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }
    } else {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    xmlSecErrorsSafeString(xmlSecNodeGetName(cur)),
                    XMLSEC_ERRORS_R_INVALID_NODE,
                    "expected=%s",
                    xmlSecErrorsSafeString(xmlSecNodeDigestMethod));
        return(-1);
    }
    dsigRefCtx->digestMethod->operation = dsigRefCtx->dsigCtx->operation;

    /* last node is required DigestValue */
    if((cur != NULL) && (xmlSecCheckNodeName(cur, xmlSecNodeDigestValue, xmlSecDSigNs))) {
        digestValueNode = cur;
        cur = xmlSecGetNextElementNode(cur->next);
    } else {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    xmlSecErrorsSafeString(xmlSecNodeGetName(cur)),
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "node=%s",
                    xmlSecErrorsSafeString(xmlSecNodeDigestValue));
        return(-1);
    }

    /* if we have something else then it's an error */
    if(cur != NULL) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    xmlSecErrorsSafeString(xmlSecNodeGetName(cur)),
                    XMLSEC_ERRORS_R_UNEXPECTED_NODE,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }

    /* if we need to write result to xml node then we need base64 encode result */
    if(dsigRefCtx->dsigCtx->operation == xmlSecTransformOperationSign) {
        xmlSecTransformPtr base64Encode;

        /* we need to add base64 encode transform */
        base64Encode = xmlSecTransformCtxCreateAndAppend(transformCtx, xmlSecTransformBase64Id);
        if(base64Encode == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxCreateAndAppend",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }
        base64Encode->operation = xmlSecTransformOperationEncode;
    }

    /* finally get transforms results */
    ret = xmlSecTransformCtxExecute(transformCtx, node->doc);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCtxExecute",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }
    dsigRefCtx->result = transformCtx->result;

    if(dsigRefCtx->dsigCtx->operation == xmlSecTransformOperationSign) {
        if((dsigRefCtx->result == NULL) || (xmlSecBufferGetData(dsigRefCtx->result) == NULL)) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxExecute",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }

        /* write signed data to xml */
        xmlNodeSetContentLen(digestValueNode,
                            xmlSecBufferGetData(dsigRefCtx->result),
                            xmlSecBufferGetSize(dsigRefCtx->result));

        /* set success status and we are done */
        dsigRefCtx->status = xmlSecDSigStatusSucceeded;
    } else {
        /* verify SignatureValue node content */
        ret = xmlSecTransformVerifyNodeContent(dsigRefCtx->digestMethod,
                            digestValueNode, transformCtx);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformVerifyNodeContent",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }

        /* set status and we are done */
        if(dsigRefCtx->digestMethod->status == xmlSecTransformStatusOk) {
            dsigRefCtx->status = xmlSecDSigStatusSucceeded;
        } else {
            dsigRefCtx->status = xmlSecDSigStatusInvalid;
        }
    }

    return(0);
}


xmlSecDSigReferenceCtxProcessNode

xmlSecTransformCtxExecute

/**
 * xmlSecTransformCtxExecute:
 * @ctx:                the pointer to transforms chain processing context.
 * @doc:                the pointer to input document.
 *
 * Executes transforms chain in @ctx.
 *
 * Returns: 0 on success or a negative value otherwise.
 */
int
xmlSecTransformCtxExecute(xmlSecTransformCtxPtr ctx, xmlDocPtr doc) {
    int ret;

    xmlSecAssert2(ctx != NULL, -1);
    xmlSecAssert2(ctx->result == NULL, -1);
    xmlSecAssert2(ctx->status == xmlSecTransformStatusNone, -1);
    xmlSecAssert2(doc != NULL, -1);

    if((ctx->uri == NULL) || (xmlStrlen(ctx->uri) == 0)) {
        xmlSecNodeSetPtr nodes;

        if((ctx->xptrExpr != NULL) && (xmlStrlen(ctx->xptrExpr) > 0)){
            /* our xpointer transform takes care of providing correct nodes set */
            nodes = xmlSecNodeSetCreate(doc, NULL, xmlSecNodeSetNormal);
            if(nodes == NULL) {
                xmlSecError(XMLSEC_ERRORS_HERE,
                            NULL,
                            "xmlSecNodeSetCreate",
                            XMLSEC_ERRORS_R_XMLSEC_FAILED,
                            XMLSEC_ERRORS_NO_MESSAGE);
                return(-1);
            }

        } else {
            /* we do not want to have comments for empty URI */
            nodes = xmlSecNodeSetGetChildren(doc, NULL, 0, 0);
            if(nodes == NULL) {
                xmlSecError(XMLSEC_ERRORS_HERE,
                            NULL,
                            "xmlSecNodeSetGetChildren",
                            XMLSEC_ERRORS_R_XMLSEC_FAILED,
                            XMLSEC_ERRORS_NO_MESSAGE);
                return(-1);
            }
        }
        ret = xmlSecTransformCtxXmlExecute(ctx, nodes);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxXmlExecute",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            xmlSecNodeSetDestroy(nodes);
            return(-1);
        }
        /* TODO: don't destroy nodes here */
        xmlSecNodeSetDestroy(nodes);
    } else {
        ret = xmlSecTransformCtxUriExecute(ctx, ctx->uri);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxUriExecute",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }
    }

    return(0);
}


xmlSecTransformCtxExecute

xmlSecTransformCtxXmlExecute

/**
 * xmlSecTransformCtxXmlExecute:
 * @ctx:                the pointer to transforms chain processing context.
 * @nodes:              the input node set.
 *
 * Process @nodes using transforms in the transforms chain in @ctx.
 *
 * Returns: 0 on success or a negative value otherwise.
 */
int
xmlSecTransformCtxXmlExecute(xmlSecTransformCtxPtr ctx, xmlSecNodeSetPtr nodes) {
    int ret;

    xmlSecAssert2(ctx != NULL, -1);
    xmlSecAssert2(ctx->result == NULL, -1);
    xmlSecAssert2(ctx->status == xmlSecTransformStatusNone, -1);
    xmlSecAssert2(nodes != NULL, -1);

    xmlSecAssert2((ctx->uri == NULL) || (xmlStrlen(ctx->uri) == 0), -1);

    ret = xmlSecTransformCtxPrepare(ctx, xmlSecTransformDataTypeXml);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCtxPrepare",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "type=xml");
        return(-1);
    }

    /* it's better to do push than pop because all XML transform
     * just don't care and c14n likes push more than pop */
    ret = xmlSecTransformPushXml(ctx->first, nodes, ctx);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformPushXml",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "transform=%s",
                    xmlSecErrorsSafeString(xmlSecTransformGetName(ctx->first)));
        return(-1);
    }

    ctx->status = xmlSecTransformStatusFinished;
    return(0);
}


xmlSecTransformPushXml

/**
 * xmlSecTransformPushXml:
 * @transform:          the pointer to transform object.
 * @nodes:              the input nodes.
 * @transformCtx:       the pointer to transform context object.
 *
 * Processes @nodes and pushes result to the next transform in the chain.
 *
 * Returns: 0 on success or a negative value if an error occurs.
 */
int
xmlSecTransformPushXml(xmlSecTransformPtr transform, xmlSecNodeSetPtr nodes,
                    xmlSecTransformCtxPtr transformCtx) {
    xmlSecAssert2(xmlSecTransformIsValid(transform), -1);
    xmlSecAssert2(transform->id->pushXml != NULL, -1);
    xmlSecAssert2(transformCtx != NULL, -1);

    return((transform->id->pushXml)(transform, nodes, transformCtx));
}

xmlSecTransformPushXml

pushXml

xmlSecTransformPushXmlD

xmlSecTransformCtxPrepare

/**
 * xmlSecTransformCtxPrepare:
 * @ctx:                the pointer to transforms chain processing context.
 * @inputDataType:      the expected input type.
 *
 * Prepares the transform context for processing data of @inputDataType.
 *
 * Returns: 0 on success or a negative value otherwise.
 */
int
xmlSecTransformCtxPrepare(xmlSecTransformCtxPtr ctx, xmlSecTransformDataType inputDataType) {
    xmlSecTransformDataType firstType;
    xmlSecTransformPtr transform;
    int ret;

    xmlSecAssert2(ctx != NULL, -1);
    xmlSecAssert2(ctx->result == NULL, -1);
    xmlSecAssert2(ctx->status == xmlSecTransformStatusNone, -1);

    /* add binary buffer to store result */
    transform = xmlSecTransformCtxCreateAndAppend(ctx, xmlSecTransformMemBufId);
    if(!xmlSecTransformIsValid(transform)) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCreate",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "transform=%s",
                    xmlSecErrorsSafeString(xmlSecTransformKlassGetName(xmlSecTransformMemBufId)));
        return(-1);
    }
    ctx->result = xmlSecTransformMemBufGetBuffer(transform);
    if(ctx->result == NULL) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformMemBufGetBuffer",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "transform=%s",
                    xmlSecErrorsSafeString(xmlSecTransformKlassGetName(xmlSecTransformMemBufId)));
        return(-1);
    }

    firstType = xmlSecTransformGetDataType(ctx->first, xmlSecTransformModePush, ctx);
    if(((firstType & xmlSecTransformDataTypeBin) == 0) &&
       ((inputDataType & xmlSecTransformDataTypeBin) != 0)) {

        /* need to add parser transform */
        transform = xmlSecTransformCtxCreateAndPrepend(ctx, xmlSecTransformXmlParserId);
        if(transform == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxCreateAndPrepend",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "transform=%s",
                        xmlSecErrorsSafeString(xmlSecTransformKlassGetName(xmlSecTransformXmlParserId)));
            return(-1);
        }
    } else if(((firstType & xmlSecTransformDataTypeXml) == 0) &&
       ((inputDataType & xmlSecTransformDataTypeXml) != 0)) {

        /* need to add c14n transform */
        transform = xmlSecTransformCtxCreateAndPrepend(ctx, xmlSecTransformInclC14NId);
        if(transform == NULL) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "xmlSecTransformCtxCreateAndPrepend",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "transform=%s",
                        xmlSecErrorsSafeString(xmlSecTransformKlassGetName(xmlSecTransformInclC14NId)));
            return(-1);
        }
    }

    /* finally let application a chance to verify that it's ok to execte
     * this transforms chain */
    if(ctx->preExecCallback != NULL) {
        ret = (ctx->preExecCallback)(ctx);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        NULL,
                        "ctx->preExecCallback",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        XMLSEC_ERRORS_NO_MESSAGE);
            return(-1);
        }
    }

    ctx->status = xmlSecTransformStatusWorking;
    return(0);
}


xmlSecTransformXmlParserId

xmlSecTransformCtxPrepare

xmlSecTransformXmlParserId

xmlSecTransformCtxCreateAndAppend

/**
 * xmlSecTransformCtxCreateAndAppend:
 * @ctx:                the pointer to transforms chain processing context.
 * @id:                 the new transform klass.
 *
 * Creaeates new transform and connects it to the end of the chain of
 * transforms in the @ctx (see #xmlSecTransformConnect function for details).
 *
 * Returns: pointer to newly created transform or NULL if an error occurs.
 */
xmlSecTransformPtr
xmlSecTransformCtxCreateAndAppend(xmlSecTransformCtxPtr ctx, xmlSecTransformId id) {
    xmlSecTransformPtr transform;
    int ret;

    xmlSecAssert2(ctx != NULL, NULL);
    xmlSecAssert2(ctx->status == xmlSecTransformStatusNone, NULL);
    xmlSecAssert2(id != xmlSecTransformIdUnknown, NULL);

    transform = xmlSecTransformCreate(id);
    if(!xmlSecTransformIsValid(transform)) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCreate",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "transform=%s",
                    xmlSecErrorsSafeString(xmlSecTransformKlassGetName(id)));
        return(NULL);
    }

    ret = xmlSecTransformCtxAppend(ctx, transform);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCtxAppend",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "name=%s",
                    xmlSecErrorsSafeString(xmlSecTransformGetName(transform)));
        xmlSecTransformDestroy(transform);
        return(NULL);
    }

    return(transform);
}


xmlSecTransformMemBufId

xmlSecTransformMemBufGetKlass

/**
 * xmlSecTransformMemBufGetKlass:
 *
 * The memory buffer transorm (used to store the data that go through it).
 *
 * Returns: memory buffer transform klass.
 */
xmlSecTransformId
xmlSecTransformMemBufGetKlass(void) {
    return(&xmlSecTransformMemBufKlass);
}


xmlSecTransformMemBufKlass

static xmlSecTransformKlass xmlSecTransformMemBufKlass = {
    /* klass/object sizes */
    sizeof(xmlSecTransformKlass),               /* xmlSecSize klassSize */
    xmlSecTransformMemBufSize,                  /* xmlSecSize objSize */

    xmlSecNameMemBuf,                           /* const xmlChar* name; */
    NULL,                                       /* const xmlChar* href; */
    0,                                          /* xmlSecAlgorithmUsage usage; */

    xmlSecTransformMemBufInitialize,            /* xmlSecTransformInitializeMethod initialize; */
    xmlSecTransformMemBufFinalize,              /* xmlSecTransformFianlizeMethod finalize; */
    NULL,                                       /* xmlSecTransformNodeReadMethod readNode; */
    NULL,                                       /* xmlSecTransformNodeWriteMethod writeNode; */
    NULL,                                       /* xmlSecTransformSetKeyReqMethod setKeyReq; */
    NULL,                                       /* xmlSecTransformSetKeyMethod setKey; */
    NULL,                                       /* xmlSecTransformValidateMethod validate; */
    xmlSecTransformDefaultGetDataType,          /* xmlSecTransformGetDataTypeMethod getDataType; */
    xmlSecTransformDefaultPushBin,              /* xmlSecTransformPushBinMethod pushBin; */
    xmlSecTransformDefaultPopBin,               /* xmlSecTransformPopBinMethod popBin; */
    NULL,                                       /* xmlSecTransformPushXmlMethod pushXml; */
    NULL,                                       /* xmlSecTransformPopXmlMethod popXml; */
    xmlSecTransformMemBufExecute,               /* xmlSecTransformExecuteMethod execute; */

    NULL,                                       /* void* reserved0; */
    NULL,                                       /* void* reserved1; */
};

#define xmlSecTransformMemBufSize \
        (sizeof(xmlSecTransform) + sizeof(xmlSecBuffer))
#define xmlSecTransformMemBufGetBuf(transform) \
    ((xmlSecTransformCheckSize((transform), xmlSecTransformMemBufSize)) ? \
        (xmlSecBufferPtr)(((xmlSecByte*)(transform)) + sizeof(xmlSecTransform)) : \
        (xmlSecBufferPtr)NULL)

static int              xmlSecTransformMemBufInitialize         (xmlSecTransformPtr transform);
static void             xmlSecTransformMemBufFinalize           (xmlSecTransformPtr transform);
static int              xmlSecTransformMemBufExecute            (xmlSecTransformPtr transform,
          

 int last,
                                                                 xmlSecTransformCtxPtr transformCtx);

xmlSecTransformMemBufInitialize

static int
xmlSecTransformMemBufInitialize(xmlSecTransformPtr transform) {
    xmlSecBufferPtr buffer;
    int ret;

    xmlSecAssert2(xmlSecTransformCheckId(transform, xmlSecTransformMemBufId), -1);

    buffer = xmlSecTransformMemBufGetBuf(transform);
    xmlSecAssert2(buffer != NULL, -1);

    ret = xmlSecBufferInitialize(buffer, 0);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
                    "xmlSecBufferInitialize",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    XMLSEC_ERRORS_NO_MESSAGE);
        return(-1);
    }
    return(0);
}


xmlSecTransformMemBufFinalize

static void
xmlSecTransformMemBufFinalize(xmlSecTransformPtr transform) {
    xmlSecBufferPtr buffer;

    xmlSecAssert(xmlSecTransformCheckId(transform, xmlSecTransformMemBufId));

    buffer = xmlSecTransformMemBufGetBuf(transform);
    xmlSecAssert(buffer != NULL);

    xmlSecBufferFinalize(xmlSecTransformMemBufGetBuf(transform));
}


xmlSecTransformMemBufExecute

static int
xmlSecTransformMemBufExecute(xmlSecTransformPtr transform, int last, xmlSecTransformCtxPtr transformCtx) {
    xmlSecBufferPtr buffer;
    xmlSecBufferPtr in, out;
    xmlSecSize inSize;
    int ret;

    xmlSecAssert2(xmlSecTransformCheckId(transform, xmlSecTransformMemBufId), -1);
    xmlSecAssert2(transformCtx != NULL, -1);

    buffer = xmlSecTransformMemBufGetBuf(transform);
    xmlSecAssert2(buffer != NULL, -1);

    in = &(transform->inBuf);
    out = &(transform->outBuf);
    inSize = xmlSecBufferGetSize(in);

    if(transform->status == xmlSecTransformStatusNone) {
        transform->status = xmlSecTransformStatusWorking;
    }

    if(transform->status == xmlSecTransformStatusWorking) {
        /* just copy everything from in to our buffer and out */
        ret = xmlSecBufferAppend(buffer, xmlSecBufferGetData(in), inSize);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
                        "xmlSecBufferAppend",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "size=%d", inSize);
            return(-1);
        }

        ret = xmlSecBufferAppend(out, xmlSecBufferGetData(in), inSize);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
                        "xmlSecBufferAppend",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "size=%d", inSize);
            return(-1);
        }

        ret = xmlSecBufferRemoveHead(in, inSize);
        if(ret < 0) {
            xmlSecError(XMLSEC_ERRORS_HERE,
                        xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
                        "xmlSecBufferRemoveHead",
                        XMLSEC_ERRORS_R_XMLSEC_FAILED,
                        "size=%d", inSize);
            return(-1);
        }

        if(last != 0) {
            transform->status = xmlSecTransformStatusFinished;
        }
    } else if(transform->status == xmlSecTransformStatusFinished) {
        /* the only way we can get here is if there is no input */
        xmlSecAssert2(inSize == 0, -1);
    } else {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    xmlSecErrorsSafeString(xmlSecTransformGetName(transform)),
                    NULL,
                    XMLSEC_ERRORS_R_INVALID_STATUS,
                    "status=%d", transform->status);
        return(-1);
    }
    return(0);
}



xmlSecTransformMemBufGetKlass

#define xmlSecTransformMemBufId \
        xmlSecTransformMemBufGetKlass()

xmlSecTransformMemBufId

xmlSecTransformMemBufGetBuffer

/**
 * xmlSecTransformMemBufGetBuffer:
 * @transform:          the pointer to memory buffer transform.
 *
 * Gets the pointer to memory buffer transform buffer.
 *
 * Returns: pointer to the transform's #xmlSecBuffer.
 */
xmlSecBufferPtr
xmlSecTransformMemBufGetBuffer(xmlSecTransformPtr transform) {
    xmlSecBufferPtr buffer;

    xmlSecAssert2(xmlSecTransformCheckId(transform, xmlSecTransformMemBufId), NULL);

    buffer = xmlSecTransformMemBufGetBuf(transform);
    xmlSecAssert2(buffer != NULL, NULL);

    return(buffer);
}


xmlSecTransformMemBufGetBuffe

xmlSecTransformCtxCreateAndAppend


/**
 * xmlSecTransformCtxCreateAndAppend:
 * @ctx:                the pointer to transforms chain processing context.
 * @id:                 the new transform klass.
 *
 * Creaeates new transform and connects it to the end of the chain of
 * transforms in the @ctx (see #xmlSecTransformConnect function for details).
 *
 * Returns: pointer to newly created transform or NULL if an error occurs.
 */
xmlSecTransformPtr xmlSecTransformCtxCreateAndAppend(xmlSecTransformCtxPtr ctx, xmlSecTransformId id) 
{
    xmlSecTransformPtr transform;
    int ret;

    xmlSecAssert2(ctx != NULL, NULL);
    xmlSecAssert2(ctx->status == xmlSecTransformStatusNone, NULL);
    xmlSecAssert2(id != xmlSecTransformIdUnknown, NULL);

    transform = xmlSecTransformCreate(id);
    if(!xmlSecTransformIsValid(transform)) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCreate",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "transform=%s",
                    xmlSecErrorsSafeString(xmlSecTransformKlassGetName(id)));
        return(NULL);
    }

    ret = xmlSecTransformCtxAppend(ctx, transform);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCtxAppend",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "name=%s",
                    xmlSecErrorsSafeString(xmlSecTransformGetName(transform)));
        xmlSecTransformDestroy(transform);
        return(NULL);
    }

    return(transform);
}


/**
 * xmlSecTransformCtxCreateAndAppend:
 * @ctx:                the pointer to transforms chain processing context.
 * @id:                 the new transform klass.
 *
 * Creaeates new transform and connects it to the end of the chain of
 * transforms in the @ctx (see #xmlSecTransformConnect function for details).
 *
 * Returns: pointer to newly created transform or NULL if an error occurs.
 */
xmlSecTransformPtr xmlSecTransformCtxCreateAndAppend(xmlSecTransformCtxPtr ctx, xmlSecTransformId id) 
{
    xmlSecTransformPtr transform;
    int ret;

    xmlSecAssert2(ctx != NULL, NULL);
    xmlSecAssert2(ctx->status == xmlSecTransformStatusNone, NULL);
    xmlSecAssert2(id != xmlSecTransformIdUnknown, NULL);

    transform = xmlSecTransformCreate(id);
    if(!xmlSecTransformIsValid(transform)) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCreate",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "transform=%s",
                    xmlSecErrorsSafeString(xmlSecTransformKlassGetName(id)));
        return(NULL);
    }

    ret = xmlSecTransformCtxAppend(ctx, transform);
    if(ret < 0) {
        xmlSecError(XMLSEC_ERRORS_HERE,
                    NULL,
                    "xmlSecTransformCtxAppend",
                    XMLSEC_ERRORS_R_XMLSEC_FAILED,
                    "name=%s",
                    xmlSecErrorsSafeString(xmlSecTransformGetName(transform)));
        xmlSecTransformDestroy(transform);
        return(NULL);
    }

    return(transform);
}


xmlSecTransformCtxCreateAndAppend

0x1001a320

10019930

100197B0

C:\xmlsec\libxmlsec-nounicode-1.2.18.win32\libxmlsec-nounicode-1.2.18.win32\lib

C:\xmlsec\libxmlsec-nounicode-1.2.18.win32\libxmlsec-nounicode-1.2.18.win32\bin\libxmlsec-mscrypto.dll

C:\xmlsec\libxmlsec-nounicode-1.2.18.win32\libxmlsec-nounicode-1.2.18.win32\bin\libxmlsec-openssl.dll

C:\xmlsec\libxmlsec-nounicode-1.2.18.win32\libxmlsec-nounicode-1.2.18.win32\bin\libxmlsec.dll

C:\Users\502525009\Documents\Visual Studio 2010\Projects\xmlsecTest\xmlsecTest\signed.cpp

/** 
 * XML Security Library example: Signing a file with a dynamicaly created template and an X509 certificate.
 * 
 * Signs a file using a dynamicaly created template, key from PEM file and
 * an X509 certificate. The signature has one reference with one enveloped 
 * transform to sign the whole document except the <dsig:Signature/> node 
 * itself. The key certificate is written in the <dsig:X509Data/> node.
 * 
 * This example was developed and tested with OpenSSL crypto library. The 
 * certificates management policies for another crypto library may break it.
 * 
 * Usage: 
 *      sign3 <xml-doc> <pem-key> 
 *
 * Example:
 *      ./sign3 sign3-doc.xml rsakey.pem rsacert.pem > sign3-res.xml
 *
 * The result signature could be validated using verify3 example:
 *      ./verify3 sign3-res.xml rootcert.pem
 *
 * This is free software; see Copyright file in the source
 * distribution for preciese wording.
 * 
 * Copyright (C) 2002-2003 Aleksey Sanin <aleksey@aleksey.com>
 */
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include <libxml/tree.h>
#include <libxml/xmlmemory.h>
#include <libxml/parser.h>

#ifndef XMLSEC_NO_XSLT
#include <libxslt/xslt.h>
#include <libxslt/security.h>
#endif /* XMLSEC_NO_XSLT */

#include <xmlsec/xmlsec.h>
#include <xmlsec/xmltree.h>
#include <xmlsec/xmldsig.h>
#include <xmlsec/templates.h>
#include <xmlsec/crypto.h>

int sign_file(const char* xml_file, const char* key_file, const char* cert_file);

int 
main(int argc, char **argv) {
#ifndef XMLSEC_NO_XSLT
    xsltSecurityPrefsPtr xsltSecPrefs = NULL;
#endif /* XMLSEC_NO_XSLT */

    assert(argv);

    if(argc != 4) {
        fprintf(stderr, "Error: wrong number of arguments.\n");
        fprintf(stderr, "Usage: %s <xml-file> <key-file> <cert-file>\n", argv[0]);
        return(1);
    }

    /* Init libxml and libxslt libraries */
    xmlInitParser();
    LIBXML_TEST_VERSION
    xmlLoadExtDtdDefaultValue = XML_DETECT_IDS | XML_COMPLETE_ATTRS;
    xmlSubstituteEntitiesDefault(1);
#ifndef XMLSEC_NO_XSLT
    xmlIndentTreeOutput = 1; 
#endif /* XMLSEC_NO_XSLT */

    /* Init libxslt */
#ifndef XMLSEC_NO_XSLT
    /* disable everything */
    xsltSecPrefs = xsltNewSecurityPrefs(); 
    xsltSetSecurityPrefs(xsltSecPrefs,  XSLT_SECPREF_READ_FILE,        xsltSecurityForbid);
    xsltSetSecurityPrefs(xsltSecPrefs,  XSLT_SECPREF_WRITE_FILE,       xsltSecurityForbid);
    xsltSetSecurityPrefs(xsltSecPrefs,  XSLT_SECPREF_CREATE_DIRECTORY, xsltSecurityForbid);
    xsltSetSecurityPrefs(xsltSecPrefs,  XSLT_SECPREF_READ_NETWORK,     xsltSecurityForbid);
    xsltSetSecurityPrefs(xsltSecPrefs,  XSLT_SECPREF_WRITE_NETWORK,    xsltSecurityForbid);
    xsltSetDefaultSecurityPrefs(xsltSecPrefs); 
#endif /* XMLSEC_NO_XSLT */
                
    /* Init xmlsec library */
    if(xmlSecInit() < 0) {
        fprintf(stderr, "Error: xmlsec initialization failed.\n");
        return(-1);
    }

    /* Check loaded library version */
    if(xmlSecCheckVersion() != 1) {
        fprintf(stderr, "Error: loaded xmlsec library version is not compatible.\n");
        return(-1);
    }

    /* Load default crypto engine if we are supporting dynamic
     * loading for xmlsec-crypto libraries. Use the crypto library
     * name ("openssl", "nss", etc.) to load corresponding 
     * xmlsec-crypto library.
     */
#ifdef XMLSEC_CRYPTO_DYNAMIC_LOADING
    if(xmlSecCryptoDLLoadLibrary(BAD_CAST XMLSEC_CRYPTO) < 0) {
        fprintf(stderr, "Error: unable to load default xmlsec-crypto library. Make sure\n"
                        "that you have it installed and check shared libraries path\n"
                        "(LD_LIBRARY_PATH) envornment variable.\n");
        return(-1);     
    }
#endif /* XMLSEC_CRYPTO_DYNAMIC_LOADING */

    /* Init crypto library */
    if(xmlSecCryptoAppInit(NULL) < 0) {
        fprintf(stderr, "Error: crypto initialization failed.\n");
        return(-1);
    }

    /* Init xmlsec-crypto library */
    if(xmlSecCryptoInit() < 0) {
        fprintf(stderr, "Error: xmlsec-crypto initialization failed.\n");
        return(-1);
    }

    if(sign_file(argv[1], argv[2], argv[3]) < 0) {
        return(-1);
    }    
    
    /* Shutdown xmlsec-crypto library */
    xmlSecCryptoShutdown();
    
    /* Shutdown crypto library */
    xmlSecCryptoAppShutdown();
    
    /* Shutdown xmlsec library */
    xmlSecShutdown();

    /* Shutdown libxslt/libxml */
#ifndef XMLSEC_NO_XSLT
    xsltFreeSecurityPrefs(xsltSecPrefs);
    xsltCleanupGlobals();            
#endif /* XMLSEC_NO_XSLT */
    xmlCleanupParser();
    
    return(0);
}

/** 
 * sign_file:
 * @xml_file:           the XML file name.
 * @key_file:           the PEM private key file name.
 * @cert_file:          the x509 certificate PEM file.
 *
 * Signs the @xml_file using private key from @key_file and dynamicaly
 * created enveloped signature template. The certificate from @cert_file
 * is placed in the <dsig:X509Data/> node.
 *
 * Returns 0 on success or a negative value if an error occurs.
 */
int 
sign_file(const char* xml_file, const char* key_file, const char* cert_file) {
    xmlDocPtr doc = NULL;
    xmlNodePtr signNode = NULL;
    xmlNodePtr refNode = NULL;
    xmlNodePtr keyInfoNode = NULL;
    xmlSecDSigCtxPtr dsigCtx = NULL;
    int res = -1;
    
    assert(xml_file);
    assert(key_file);
    assert(cert_file);

    /* load doc file */
    doc = xmlParseFile(xml_file);
    if ((doc == NULL) || (xmlDocGetRootElement(doc) == NULL)){
        fprintf(stderr, "Error: unable to parse file \"%s\"\n", xml_file);
        goto done;      
    }
    
    /* create signature template for RSA-SHA1 enveloped signature */
    signNode = xmlSecTmplSignatureCreate(doc, xmlSecTransformExclC14NId,
                                         xmlSecTransformRsaSha1Id, NULL);
    if(signNode == NULL) {
        fprintf(stderr, "Error: failed to create signature template\n");
        goto done;              
    }

    /* add <dsig:Signature/> node to the doc */
    xmlAddChild(xmlDocGetRootElement(doc), signNode);
    
    /* add reference */
    refNode = xmlSecTmplSignatureAddReference(signNode, xmlSecTransformSha1Id,
                                        NULL, NULL, NULL);
    if(refNode == NULL) {
        fprintf(stderr, "Error: failed to add reference to signature template\n");
        goto done;              
    }

    /* add enveloped transform */
    if(xmlSecTmplReferenceAddTransform(refNode, xmlSecTransformEnvelopedId) == NULL) {
        fprintf(stderr, "Error: failed to add enveloped transform to reference\n");
        goto done;              
    }
    
    /* add <dsig:KeyInfo/> and <dsig:X509Data/> */
    keyInfoNode = xmlSecTmplSignatureEnsureKeyInfo(signNode, NULL);
    if(keyInfoNode == NULL) {
        fprintf(stderr, "Error: failed to add key info\n");
        goto done;              
    }
    
    if(xmlSecTmplKeyInfoAddX509Data(keyInfoNode) == NULL) {
        fprintf(stderr, "Error: failed to add X509Data node\n");
        goto done;              
    }

    /* create signature context, we don't need keys manager in this example */
    dsigCtx = xmlSecDSigCtxCreate(NULL);
    if(dsigCtx == NULL) {
        fprintf(stderr,"Error: failed to create signature context\n");
        goto done;
    }

    /* load private key, assuming that there is not password */
    dsigCtx->signKey = xmlSecCryptoAppKeyLoad(key_file, xmlSecKeyDataFormatPem, NULL, NULL, NULL);
    if(dsigCtx->signKey == NULL) {
        fprintf(stderr,"Error: failed to load private pem key from \"%s\"\n", key_file);
        goto done;
    }
    
    /* load certificate and add to the key */
    if(xmlSecCryptoAppKeyCertLoad(dsigCtx->signKey, cert_file, xmlSecKeyDataFormatPem) < 0) {
        fprintf(stderr,"Error: failed to load pem certificate \"%s\"\n", cert_file);
        goto done;
    }

    /* set key name to the file name, this is just an example! */
    if(xmlSecKeySetName(dsigCtx->signKey, key_file) < 0) {
        fprintf(stderr,"Error: failed to set key name for key from \"%s\"\n", key_file);
        goto done;
    }

    /* sign the template */
    if(xmlSecDSigCtxSign(dsigCtx, signNode) < 0) {
        fprintf(stderr,"Error: signature failed\n");
        goto done;
    }
        
    /* print signed document to stdout */
    xmlDocDump(stdout, doc);
    
    /* success */
    res = 0;

done:    
    /* cleanup */
    if(dsigCtx != NULL) {
        xmlSecDSigCtxDestroy(dsigCtx);
    }
    
    if(doc != NULL) {
        xmlFreeDoc(doc); 
    }
    return(res);
}



mainsigning

Programming Research Ltd 

Hello,
     I need to develop code which will sign, and verify, a XML message. Once its signed the signing has to be certifies with a 509 certificate. There seems to be a reasonably good amount of information on the web about doing all this in C# or Java which I can use for test purposes, but I need to develop my main code in 'C' and it has to be light weight and free from dll's. 
I found one website www.aleksey.com which does have some code I could use, but it seems quite heavy and I needs something more stripped down and light weight. 
I was using TinyXML to do the original XML parsing but that doesn't seem to have a signing part to it.

Would anyone be able to point me in the right direction or to the right website, any information I would be very greatful. 

Thanks.

extern void SendTextToWindow(const char * text);

HandleControlRequestData

DecodeNVFB3

ExtractTheNVFB3Header

UINT16 hdr_crcTable_16[256];
UINT16 CCITT_crcTable_16[256];
UINT32 CRC32_Table [256];

UINT16 hdr_poly = 0x81a0;		// incorrect old version of Allstom poly to match test data
// UINT16 hdr_poly = 0x91a0;	// the correct version
UINT16 CCITT_poly = 0x8810;

void buildCrc16Table(UINT16* table, UINT16 polynom) 
{
	for (UINT16 x = 0; x < 256; x++) 
	{
		UINT16 w = x;
		for (int i = 0; i < 8; i++) 
		{
			if ((w & 1) != 0) 
			{
				w = (w >> 1) ^ polynom;
			} 
			else 
			{
				w = w >> 1;
			}
		}
		table[x] = (short) w;
	}
}

void buildCRC32_Table()
{
	UINT32 CRC32_POLYNOMIAL = 0x8806A731;

	int i, j;
	UINT32 crc;

	for (i = 0; i <= 255; i++) 
	{
		crc = i;
		for (j = 8; j > 0; j--)
		{
			if ((crc & 1) == 1)
				crc = (crc >> 1) ^ CRC32_POLYNOMIAL;
			else
				crc >>= 1;
		}

		CRC32_Table[i] = crc;
	}
}

void init_crc_tables()
{
	buildCRC32_Table();

	buildCrc16Table(hdr_crcTable_16, hdr_poly);
	buildCrc16Table(CCITT_crcTable_16, CCITT_poly);
}

void crcInit(void)
{
	init_crc_tables();
}

UINT16 calculate_crc_16(UINT16* table, BYTE *data, size_t length) 
{
	int p;

	UINT16 crc = 0;
	for (p = 0; p < length; p++) 
	{
		crc =	(crc >> 8) ^ 
				(table[(crc & 0xFF) ^ (data[p] & 0xFF)] & 0xFFFF);
	}
	return crc;
}

UINT16 calculate_hdr_crc_16(BYTE *data, size_t length) 
{
	return calculate_crc_16(hdr_crcTable_16, data, length);
}

UINT16 calculate_CCITT_crc_16(BYTE *data, size_t length) 
{
	return calculate_crc_16(CCITT_crcTable_16, data, length);
}

UINT32 calculate_crc_32(BYTE *buffer, int count, int lastcrc)
{
	UINT32 temp1, temp2;
	int i = 0;

	UINT32 crc = lastcrc;

	while (count-- != 0) 
	{
		temp1 = crc >> 8;
		temp2 = CRC32_Table[(crc ^ buffer[i++]) & 0xFF];
		crc = temp1 ^ temp2;
	}

	return crc;
}



calculate_hdr_crc_16

RSA_ToXMLString

  // Create an XmlDocument object.
            XmlDocument xmlDoc = new XmlDocument();

            // Load an XML file into the XmlDocument object.
            xmlDoc.PreserveWhitespace = true;
            xmlDoc.Load("test.xml");

            // Open the X.509 "Current User" store in read only mode.
            X509Store store = new X509Store(StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadOnly);

            // Place all certificates in an X509Certificate2Collection object.
            X509Certificate2Collection certCollection = store.Certificates;

            X509Certificate2 cert = null;

            // Loop through each certificate and find the certificate 
            // with the appropriate name.
            foreach (X509Certificate2 c in certCollection)
            {
                if (c.Subject == "CN=XML_ENC_TEST_CERT")
                {
                    cert = c;

                    break;
                }
            }

            if (cert == null)
            {
                throw new CryptographicException("The X.509 certificate could not be found.");
            }

            // Close the store.
            store.Close();

            // Encrypt the "creditcard" element.
            Encrypt(xmlDoc, "creditcard", cert);

            // Save the XML document.
            xmlDoc.Save("test.xml");

            // Display the encrypted XML to the console.
            Console.WriteLine("Encrypted XML:");
            Console.WriteLine();
            Console.WriteLine(xmlDoc.OuterXml);


 public static void Encrypt(XmlDocument Doc, string ElementToEncrypt, X509Certificate2 Cert)
    {
        // Check the arguments.  
        if (Doc == null)
            throw new ArgumentNullException("Doc");
        if (ElementToEncrypt == null)
            throw new ArgumentNullException("ElementToEncrypt");
        if (Cert == null)
            throw new ArgumentNullException("Cert");

        ////////////////////////////////////////////////
        // Find the specified element in the XmlDocument
        // object and create a new XmlElemnt object.
        ////////////////////////////////////////////////

        XmlElement elementToEncrypt = Doc.GetElementsByTagName(ElementToEncrypt)[0] as XmlElement;
        // Throw an XmlException if the element was not found.
        if (elementToEncrypt == null)
        {
            throw new XmlException("The specified element was not found");

        }

        //////////////////////////////////////////////////
        // Create a new instance of the EncryptedXml class 
        // and use it to encrypt the XmlElement with the 
        // X.509 Certificate.
        //////////////////////////////////////////////////

        EncryptedXml eXml = new EncryptedXml();

        // Encrypt the element.
        EncryptedData edElement = eXml.Encrypt(elementToEncrypt, Cert);

        ////////////////////////////////////////////////////
        // Replace the element from the original XmlDocument
        // object with the EncryptedData element.
        ////////////////////////////////////////////////////
        EncryptedXml.ReplaceElement(elementToEncrypt, edElement, false);
    }

<root>
    <creditcard>
        <number>19834209</number>
        <expiry>02/02/2002</expiry>
    </creditcard>
</root>

C:\Users\502525009\Documents\Visual Studio 2010\Projects\xmlSigning\xmlSigning\bin\Debug\test.xml

makecert -r -pe -n "CN=XML_ENC_TEST_CERT" -b 01/01/2005 -e 01/01/2010 -sky exchange -ss my

<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
 xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" elementFormDefault="qualified">

 <!-- Import the XML Digital Signature XSD -->
 <xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
  schemaLocation="xmldsig-core-schema.xsd" />

 <!-- Custom Types -->
 <xs:simpleType name="nonEmptyString">
  <xs:restriction base="xs:string">
   <xs:minLength value="1" />
  </xs:restriction>
 </xs:simpleType>

 <!-- Version Number format, e.g. message/data/software etc... -->
 <xs:simpleType name="versionNumber">
  <xs:restriction base="xs:string">
   <xs:minLength value="1" />
   <xs:pattern value="[a-z0-9\-]*" />
  </xs:restriction>
 </xs:simpleType>

 <!-- Sequence Numbering -->
 <xs:simpleType name="sequenceNumber">
  <xs:restriction base="xs:int">
   <xs:minInclusive value="1" />
   <xs:maxInclusive value="2147483647" />
  </xs:restriction>
 </xs:simpleType>

 <!-- Unit Identifiers e.g. RIF-1-A etc... -->
 <xs:simpleType name="unitID">
  <xs:restriction base="xs:string">
   <xs:minLength value="1" />
  </xs:restriction>
 </xs:simpleType>

 <!-- Identifiers for remote links and other remote equipment -->
 <xs:simpleType name="equipmentID">
  <xs:restriction base="xs:string">
   <xs:minLength value="1" />
  </xs:restriction>
 </xs:simpleType>

 <!-- Track circuit ID's -->
 <xs:simpleType name="trackID">
  <xs:restriction base="xs:string">
   <xs:minLength value="1" />
  </xs:restriction>
 </xs:simpleType>

 <!-- Signal Names -->
 <xs:simpleType name="signalID">
  <xs:restriction base="xs:string">
   <xs:minLength value="1" />
  </xs:restriction>
 </xs:simpleType>

 <!-- How requests are identified -->
 <xs:simpleType name="requestID">
  <xs:restriction base="xs:int">
   <xs:minInclusive value="1" />
  </xs:restriction>
 </xs:simpleType>

 <!-- ARS Sub-Area identifier -->
 <xs:simpleType name="arsSubAreaID">
  <xs:restriction base="xs:int">
   <xs:minInclusive value="1" />
  </xs:restriction>
 </xs:simpleType>

 <!-- Berth identifier -->
 <xs:simpleType name="berthID">
  <xs:restriction base="xs:string">
   <xs:minLength value="1" />
  </xs:restriction>
 </xs:simpleType>

<xs:simpleType name="trainID">
  <xs:restriction base="xs:string">
   <xs:minLength value="1" />
  </xs:restriction>
 </xs:simpleType>

 <!-- An SSI ID, e.g. 0F or 1B -->
 <xs:simpleType name="SSIID">
  <xs:restriction base="xs:string">
   <xs:pattern value="[0-9A-Z]{2}" />
  </xs:restriction>
 </xs:simpleType>

 <!-- How the time sync status should be described -->
 <xs:simpleType name="timeStatus">
  <xs:restriction base="xs:string">
   <xs:enumeration value="SYNCHRONISED" />
   <xs:enumeration value="UNSYNCHRONISED" />
  </xs:restriction>
 </xs:simpleType>

 <!-- How the unit status can be described -->
 <xs:simpleType name="unitStatus">
  <xs:restriction base="xs:string">
   <xs:enumeration value="MASTER" />
   <xs:enumeration value="STANDBY" />
   <xs:enumeration value="UNAVAILABLE" />
   <xs:enumeration value="ACTIVE" />
   <xs:enumeration value="INACTIVE" />
  </xs:restriction>
 </xs:simpleType>

 <!-- The description of links to external systems -->
 <xs:simpleType name="linkStatus">
  <xs:restriction base="xs:string">
   <xs:enumeration value="UP" />
   <xs:enumeration value="DOWN" />
  </xs:restriction>
 </xs:simpleType>

 <!-- Link availability -->
 <xs:simpleType name="sourceLinkStatus">
  <xs:restriction base="xs:string">
   <xs:enumeration value="UP" />
   <xs:enumeration value="DOWN" />
   <xs:enumeration value="AVAILABLE" />
  </xs:restriction>
 </xs:simpleType>

 <!-- NVFB/3 data, base64 encoded -->
 <xs:simpleType name="NVFB3">
  <xs:restriction base="xs:base64Binary" />
 </xs:simpleType>

 <!-- Header Elements -->
 <xs:element name="Version">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="MessageFormat" type="versionNumber"
     minOccurs="1" maxOccurs="1" />
    <xs:element name="Data" type="versionNumber" minOccurs="1"
     maxOccurs="1" />
    <xs:element name="Software" type="versionNumber"
     minOccurs="1" maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="Time">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="Current" type="xs:dateTime" minOccurs="1"
     maxOccurs="1" />
    <xs:element name="TimeStatus" type="timeStatus"
     minOccurs="1" maxOccurs="1" />
    <xs:element name="Monotonic" type="xs:long" minOccurs="1"
     maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="Header">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="Version" minOccurs="1" maxOccurs="1" />
    <xs:element ref="Time" minOccurs="1" maxOccurs="1" />
    <xs:element name="SequenceNumber" type="sequenceNumber"
     minOccurs="1" maxOccurs="1" />
    <xs:element name="SourceUnitID" type="unitID" minOccurs="1"
     maxOccurs="1" />
    <xs:element name="LogicalSourceID" type="unitID"
     minOccurs="1" maxOccurs="1" />
    <xs:element name="SourceStatus" type="unitStatus"
     minOccurs="1" maxOccurs="1" />
    <xs:element name="SourceLinkStatus" type="sourceLinkStatus"
     minOccurs="1" maxOccurs="1" />
    <xs:element name="DestinationUnitID" type="unitID"
     minOccurs="1" maxOccurs="1" />
    <xs:element name="LogicalDestinationID" type="unitID"
     minOccurs="1" maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <!-- Body Elements -->

 <xs:element name="Link">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="From" type="equipmentID" minOccurs="1"
     maxOccurs="1" />
    <xs:element name="To" type="equipmentID" minOccurs="1"
     maxOccurs="1" />
    <xs:element name="Status" type="linkStatus" minOccurs="1"
     maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="DiagnosticAlarms">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="Link" minOccurs="0" maxOccurs="unbounded" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="OSTO">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="Track1" type="trackID" minOccurs="1"
     maxOccurs="1" />
    <xs:element name="Track2" type="trackID" minOccurs="1"
     maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="GeneratedAlarms">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="OSTO" minOccurs="0" maxOccurs="unbounded" />
    <xs:element name="GenericAlarm" type="nonEmptyString"
     minOccurs="0" maxOccurs="unbounded" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="SPADData">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="SignalID" type="xs:int" minOccurs="1"
     maxOccurs="1" />
    <xs:element name="Signal" type="signalID" minOccurs="1"
     maxOccurs="1" />
    <xs:element name="Track" type="trackID" minOccurs="1"
     maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="SPAD">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="SignalMap" type="NVFB3" minOccurs="0"
     maxOccurs="1" />
    <xs:element name="SignalMapResponse" type="NVFB3" minOccurs="0"
     maxOccurs="1" />
    <xs:element ref="SPADData" minOccurs="0" maxOccurs="unbounded" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="ControlRequestRejected">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="RequestNumber" type="requestID"
     minOccurs="1" maxOccurs="1" />
    <xs:element name="RejectReason" type="nonEmptyString"
     minOccurs="1" maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="Interlocking">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="UniqueID" type="nonEmptyString"
     minOccurs="1" maxOccurs="1" />
    <xs:element name="SSIID" type="SSIID" minOccurs="1"
     maxOccurs="1" />
    <xs:element ref="SPAD" minOccurs="0" maxOccurs="unbounded" />
    <xs:element name="Indications" type="NVFB3" minOccurs="0"
     maxOccurs="1" />
    <xs:element name="IndicationsResponse" type="NVFB3" minOccurs="0"
     maxOccurs="1" />
    <xs:element name="ControlRequests" type="NVFB3"
     minOccurs="0" maxOccurs="1" />
    <xs:element name="ControlRequestsResponse" type="NVFB3"
     minOccurs="0" maxOccurs="1" />
    <xs:element ref="ControlRequestRejected" minOccurs="0"
     maxOccurs="unbounded" />
    <xs:element name="ARSDisableSubArea" type="arsSubAreaID"
     minOccurs="0" maxOccurs="unbounded" />
    <xs:element name="ARSSubAreaStatus" type="NVFB3"
     minOccurs="0" maxOccurs="1" />
    <xs:element name="ARSSubAreaStatusResponse" type="NVFB3"
     minOccurs="0" maxOccurs="1" />
    <xs:element name="StatusByte" type="NVFB3" minOccurs="0"
     maxOccurs="1" />
    <xs:element name="StatusByteResponse" type="NVFB3" minOccurs="0"
     maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="Interpose">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="TrainID" type="trainID" minOccurs="1"
     maxOccurs="1" />
    <xs:element name="Berth" type="berthID" minOccurs="1"
     maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="Clear">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="Berth" type="berthID" minOccurs="1"
     maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="Step">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="TrainID" type="trainID" minOccurs="1"
     maxOccurs="1" />
    <xs:element name="FromBerth" type="berthID" minOccurs="1"
     maxOccurs="1" />
    <xs:element name="ToBerth" type="berthID" minOccurs="1"
     maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="TD">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="Interpose" minOccurs="0" maxOccurs="unbounded" />
    <xs:element ref="Clear" minOccurs="0" maxOccurs="unbounded" />
    <xs:element ref="Step" minOccurs="0" maxOccurs="unbounded" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <xs:element name="Body">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="DiagnosticAlarms" minOccurs="0"
     maxOccurs="1" />
    <xs:element ref="GeneratedAlarms" minOccurs="0"
     maxOccurs="1" />
    <xs:element ref="Interlocking" minOccurs="0" maxOccurs="20" />
    <xs:element name="EmergencyAlarms" type="NVFB3"
     minOccurs="0" maxOccurs="1" />
    <xs:element name="EmergencyAlarmsResponse" type="NVFB3"
     minOccurs="0" maxOccurs="1" />
    <xs:element ref="TD" minOccurs="0" maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <!-- Message Element -->

 <xs:element name="Message">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="Header" minOccurs="1" maxOccurs="1" />
    <xs:element ref="Body" minOccurs="1" maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>

 <!-- Envelope Element -->
 <xs:element name="Envelope">
  <xs:complexType>
   <xs:sequence>
    <xs:element ref="Message" minOccurs="1" maxOccurs="1" />
    <!-- set minOccurs to 1 to mandate signatures, 0 to have them optional -->
    <xs:element ref="dsig:Signature" minOccurs="0" maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>
</xs:schema>


C:\srif\ICONIS.cxx

C:\srif\ICONIS.hxx

C:\srif\ICONIS.xml

C:\srif\ICONIS.xsd

C:\srif\ICONIS.cs


</xs:schema>

SignatureType

 <xs:complexType>
   <xs:sequence>
    <xs:element ref="Header" minOccurs="1" maxOccurs="1" />
    <xs:element ref="Body" minOccurs="1" maxOccurs="1" />
   </xs:sequence>
  </xs:complexType>
 </xs:element>


base="xs:string">

nonEmptyString

C:\srif\Win32Srif4_3\minyEncoder\XML\ICONIS.cs

if (output != null)
                {

public static byte[] StringToByteArray(string hex) {
    return Enumerable.Range(0, hex.Length)
                     .Where(x => x % 2 == 0)
                     .Select(x => Convert.ToByte(hex.Substring(x, 2), 16))
                     .ToArray();
}

StringToByteArray

StringToByteArray(

 System.Text.RegularExpressions.Regex.IsMatch(test, @"\A\b[0-9a-fA-F]+\b\Z");

VerifyHexNumber

textbox.Text

CheckTexBoxesandEnableOK();

 CheckTexBoxesandEnableOK();

VerifyHexNumber

if (ApplicationDomainTextBox.Text.Length < 3)
            {
                CheckTexBoxesandEnableOK();
            }
            else
            {
                OKButton.Enabled = false;
            }

VerifyHexNumber(

Envelope configdata

XmlSerializer serializer = new XmlSerializer(typeof(Envelope));
                StreamReader reader = new StreamReader("lastconfig.xml");
                configdata =  (Envelope)serializer.Deserialize(reader);

result

lastconfig.xml

string.Format("{0:x}", data[0].ToString());

resultNoSignature

"<Envelope>"

"</Envelope>"

resultNoSignature

resultNoSignature = "<Envelope>" + result + "</Envelope>";

SourceUnitIDTextBox

LogicalSourceIDTesxtBox

interlockingList

repopulateInterlockingList

enableButtons

  public static byte[] StringToByteArray(string hex)
        {
            return Enumerable.Range(0, hex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(hex.Substring(x, 2), 16))
                             .ToArray();
        }

    public static byte[] StringToByteArray(string hex)
        {
            return Enumerable.Range(0, hex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(hex.Substring(x, 2), 16))
                             .ToArray();
        }

StringToByteArray

   public static byte[] StringToByteArray(string hex)
        {
            return Enumerable.Range(0, hex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(hex.Substring(x, 2), 16))
                             .ToArray();
        }

StringToByteArray

ByteArrayToString

List<byte> temp = new List<byte>();
                foreach (byte b in data.ControlRequests)
                {
                    temp.Add(b);
                }
                temp.RemoveAt(temp.Count - 1);
                temp.RemoveAt(temp.Count - 1);


data.ARSSubAreaStatus 

		result	"<Envelope><Message xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"><Header><Version><MessageFormat>message-v0.1</MessageFormat><Data>data-v0.1</Data><Software>software-v1</Software></Version><Time><Current>2015-10-01T16:26:00.0098791+01:00</Current><TimeStatus>SYNCHRONISED</TimeStatus><Monotonic>260560607</Monotonic></Time><SequenceNumber>0</SequenceNumber><SourceUnitID>ICONIS-1-Unit-A</SourceUnitID><LogicalSourceID>ICONIS-1</LogicalSourceID><SourceStatus>MASTER</SourceStatus><SourceLinkStatus>UP</SourceLinkStatus><DestinationUnitID>SRIF-1-Unit-A</DestinationUnitID><LogicalDestinationID>SRIF-1</LogicalDestinationID></Header><Body><Interlocking><UniqueID>4</UniqueID><SSIID>4</SSIID><ControlRequests>o6MBAAEA39aHDwEAAACqVXwAAQAAANj7lS71zaOjAQABADdegw8BAAAAqlVeAAEAAACwsDmJihajowEAAQA0u2YPAQAAAKpVQAABAAAAj6TyjiZDMDEwMjAzMDAwNDAwMDUwMDAwMDAwNjAwMDAwMDA3MDAwMjAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMzAzOTG9g/aaJg==</ControlRequests></Interlocking></Body></Message><Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\"><SignedInfo><CanonicalizationMethod Algorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" /><SignatureMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\" /><Reference URI=\"\"><Transforms><Transform Algorithm=\"http://www.w3.org/2000/09/xmldsig#enveloped-signature\" /></Transforms><DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\" /><DigestValue>9jHfpiMS3qocbiPobSojHMKRq9E=</DigestValue></Reference></SignedInfo><SignatureValue>Gk+nca4/KvS0k5jIkM+Raexua/OVbx+c6qC0pIb0u2LoUzkUun6fpWwKOsVZcy0kuIIF2av6rkDo0Qeml4Ms9fkfZ1JV7FRRb3UXQrklv9P26dysSzOBNy3kz/quWhsTK3Fxv9Euvh8Fjf5U49W0uSWZVZsCHGgl2ehWRgUcI/Q=</SignatureValue></Signature></Envelope>"	string


