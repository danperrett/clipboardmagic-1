C:\Users\502525009\Documents\Visual Studio 2010\Projects\exampleWin32Proj\Debug\SSLSRIF.exe

/*
    Simple UDP Server
    Silver Moon ( m00n.silv3r@gmail.com )
*/
 
#include<stdio.h>
#include<winsock2.h>
 
#pragma comment(lib,"ws2_32.lib") //Winsock Library
 
#define BUFLEN 512  //Max length of buffer
#define PORT 8888   //The port on which to listen for incoming data
 
int main()
{
    SOCKET s;
    struct sockaddr_in server, si_other;
    int slen , recv_len;
    char buf[BUFLEN];
    WSADATA wsa;
 
    slen = sizeof(si_other) ;
     
    //Initialise winsock
    printf("\nInitialising Winsock...");
    if (WSAStartup(MAKEWORD(2,2),&wsa) != 0)
    {
        printf("Failed. Error Code : %d",WSAGetLastError());
        exit(EXIT_FAILURE);
    }
    printf("Initialised.\n");
     
    //Create a socket
    if((s = socket(AF_INET , SOCK_DGRAM , 0 )) == INVALID_SOCKET)
    {
        printf("Could not create socket : %d" , WSAGetLastError());
    }
    printf("Socket created.\n");
     
    //Prepare the sockaddr_in structure
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons( PORT );
     
    //Bind
    if( bind(s ,(struct sockaddr *)&server , sizeof(server)) == SOCKET_ERROR)
    {
        printf("Bind failed with error code : %d" , WSAGetLastError());
        exit(EXIT_FAILURE);
    }
    puts("Bind done");
 
    //keep listening for data
    while(1)
    {
        printf("Waiting for data...");
        fflush(stdout);
         
        //clear the buffer by filling null, it might have previously received data
        memset(buf,'\0', BUFLEN);
         
        //try to receive some data, this is a blocking call
        if ((recv_len = recvfrom(s, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen)) == SOCKET_ERROR)
        {
            printf("recvfrom() failed with error code : %d" , WSAGetLastError());
            exit(EXIT_FAILURE);
        }
         
        //print details of the client/peer and the data received
        printf("Received packet from %s:%d\n", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port));
        printf("Data: %s\n" , buf);
         
        //now reply the client with the same data
        if (sendto(s, buf, recv_len, 0, (struct sockaddr*) &si_other, slen) == SOCKET_ERROR)
        {
            printf("sendto() failed with error code : %d" , WSAGetLastError());
            exit(EXIT_FAILURE);
        }
    }
 
    closesocket(s);
    WSACleanup();
     
    return 0;
}

/*
    Simple udp client
    Silver Moon (m00n.silv3r@gmail.com)
*/
#include<stdio.h>
#include<winsock2.h>
 
#pragma comment(lib,"ws2_32.lib") //Winsock Library
 
#define SERVER "127.0.0.1"  //ip address of udp server
#define BUFLEN 512  //Max length of buffer
#define PORT 8888   //The port on which to listen for incoming data
 
int main(void)
{
    struct sockaddr_in si_other;
    int s, slen=sizeof(si_other);
    char buf[BUFLEN];
    char message[BUFLEN];
    WSADATA wsa;
 
    //Initialise winsock
    printf("\nInitialising Winsock...");
    if (WSAStartup(MAKEWORD(2,2),&wsa) != 0)
    {
        printf("Failed. Error Code : %d",WSAGetLastError());
        exit(EXIT_FAILURE);
    }
    printf("Initialised.\n");
     
    //create socket
    if ( (s=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == SOCKET_ERROR)
    {
        printf("socket() failed with error code : %d" , WSAGetLastError());
        exit(EXIT_FAILURE);
    }
     
    //setup address structure
    memset((char *) &si_other, 0, sizeof(si_other));
    si_other.sin_family = AF_INET;
    si_other.sin_port = htons(PORT);
    si_other.sin_addr.S_un.S_addr = inet_addr(SERVER);
     
    //start communication
    while(1)
    {
        printf("Enter message : ");
        gets(message);
         
        //send the message
        if (sendto(s, message, strlen(message) , 0 , (struct sockaddr *) &si_other, slen) == SOCKET_ERROR)
        {
            printf("sendto() failed with error code : %d" , WSAGetLastError());
            exit(EXIT_FAILURE);
        }
         
        //receive a reply and print it
        //clear the buffer by filling null, it might have previously received data
        memset(buf,'\0', BUFLEN);
        //try to receive some data, this is a blocking call
        if (recvfrom(s, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen) == SOCKET_ERROR)
        {
            printf("recvfrom() failed with error code : %d" , WSAGetLastError());
            exit(EXIT_FAILURE);
        }
         
        puts(buf);
    }
 
    closesocket(s);
    WSACleanup();
 
    return 0;
}

WORD fd 

WORD fd

fd

wParam

NumberOfConncetions

C:\Users\502525009\Documents\Visual Studio 2010\Projects\exampleWin32Proj\Debug\SSLSRIF.exe

 if((bindRet = bind(hSocket, (SOCKADDR*)&sockIn, sizeof(sockIn))) == SOCKET_ERROR)
        return bindRet;

recvfrom

SocketReceiveUDP

5132

#define Version  1004


1639

5132

 count++;

int main()
{
    SOCKET s;
    struct sockaddr_in server, si_other;
    int slen , recv_len;
    char buf[BUFLEN];
    WSADATA wsa;
 
    slen = sizeof(si_other) ;
     
    //Initialise winsock
    printf("\nInitialising Winsock...");
    if (WSAStartup(MAKEWORD(2,2),&wsa) != 0)
    {
        printf("Failed. Error Code : %d",WSAGetLastError());
        exit(EXIT_FAILURE);
    }
    printf("Initialised.\n");
     
    //Create a socket
    if((s = socket(AF_INET , SOCK_DGRAM , 0 )) == INVALID_SOCKET)
    {
        printf("Could not create socket : %d" , WSAGetLastError());
    }
    printf("Socket created.\n");
     
    //Prepare the sockaddr_in structure
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons( PORT );
     
    //Bind
    if( bind(s ,(struct sockaddr *)&server , sizeof(server)) == SOCKET_ERROR)
    {
        printf("Bind failed with error code : %d" , WSAGetLastError());
        exit(EXIT_FAILURE);
    }
    puts("Bind done");
 
    //keep listening for data
    while(1)
    {
        printf("Waiting for data...");
        fflush(stdout);
         
        //clear the buffer by filling null, it might have previously received data
        memset(buf,'\0', BUFLEN);
         
        //try to receive some data, this is a blocking call
        if ((recv_len = recvfrom(s, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen)) == SOCKET_ERROR)
        {
            printf("recvfrom() failed with error code : %d" , WSAGetLastError());
            exit(EXIT_FAILURE);
        }
         
        //print details of the client/peer and the data received
        printf("Received packet from %s:%d\n", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port));
        printf("Data: %s\n" , buf);
         
        //now reply the client with the same data
        if (sendto(s, buf, recv_len, 0, (struct sockaddr*) &si_other, slen) == SOCKET_ERROR)
        {
            printf("sendto() failed with error code : %d" , WSAGetLastError());
            exit(EXIT_FAILURE);
        }
    }
 
    closesocket(s);
    WSACleanup();
     
    return 0;
}

CreateThread(NULL, MCS_IF_STACK_SIZE, &MSCCE_THREAD, &AppInit, 0, 0);

CreateThread

CreateThread(0, 0, myThread, &myCounter, 0, &myThreadID);

DWORD WINAPI myThread(LPVOID lpParameter)

recvThread

DWORD WINAPI recvThread(LPVOID lpParameter)

if(!(count&0x1FF))
    {
        SendUDPMessage("127.0.0.1", "test");
       
    }
     count++;

change

DWORD sequenceNumber = 0;

sequenceNumber

connectionStatus

CqMPAAUAWbvdpJ933aSqVRAAAQAAABPkQTpBfgAAAAAAAAAAAAAAAAAAAAAhog==

CqMPAAUAabvdpEaq3aSqVRAAAQAAAIJHPQHplQAAAAAAAAAAAAAAAAAAAAAcDQ==

CqMPAAUAU7zdpJ933aSqVRAAAQAAALoDVwkj7gAAAAAAAAAAAAAAAAAAAAARJw==

 sequenceNumber++;

DWORD sequenceNumber = 0;

C:\Users\502525009\Documents\Visual Studio 2010\Projects\exampleWin32Proj\Debug\SSLSRIF.exe

connectionInformation->connectionInformation

ConnectionList[n].connectionInformation.

ConnectionList

connectionInformation

connectionInformation.SourceStatus.value

MAX_NUMBER_OF_CONNECTIONS

WORD isMaster(WORD connectionID)

connectionID

isMaster

isMaster(ConnectionID);

SourceStatus

SourceStatusTextBox

mess.Header.SourceStatus

 XMLDocument doc;
    XMLError error = doc.Parse( input );

decodeInterSRIFMessage

 if(error == XML_SUCCESS)
    {

 XMLElement *Message = Envelope->FirstChildElement("Message");

XMLElement *Envelope = doc.FirstChildElement();
        XMLElement *Message = Envelope->FirstChildElement("Message");

CHECKANDEXIT

decodeInterSRIFMessage

CHECKANDEXIT(Message, "decodeInterSRIFMessage Message");

CHECKANDEXIT(Status, "decodeInterSRIFMessage Status");

XMLElement *Status = Message->FirstChildElement("Status");

CHECKANDEXIT(Status, "decodeInterSRIFMessage Status");

CHECKANDEXIT(SequenceNumber

"decodeInterSRIFMessage SequenceNumber");

SequenceNumber

*rxIP = socket.sin_addr.S_un.S_addr;
    *PortNumber = socket.sin_port;

si_other

localconnecstatus

connectionStatus

localconnecstatus

InterMachineLink

GetPrivateProfileString

IPAddress1

GetPrivateProfileString("InterMachineLink", "IPAddress1", "None", value, sizeof(value), iniFilename);

value

strcpy(AppInit.ImlIP1, value);

AppInit

AppInit.ImlIP1

SendUDPMessage(AppInit.ImlIP1, buffer);

C:\Users\502525009\Documents\Visual Studio 2010\Projects\exampleWin32Proj\Debug\SSLSRIF.exe

E:\SRIF_docs

E:\SourceCode_1215

E:\SourceCode_1215

SocketInit();

C:\Users\502525009\Documents\Visual Studio 2010\Projects\exampleWin32Proj\Debug\SSLSRIF.exe

CRITICAL_SECTION m_cs

m_cs

CRITICAL_SECTION sequence_CS;

InitializeCriticalSection

sequence_CS

bufOut_cs

EnterCriticalSection(&bufOut_cs);

 EnterCriticalSection(&sequence_CS);

 LeaveCriticalSection(&sequence_CS);

CRITICAL_SECTION sequence_CS;

 EnterCriticalSection(&sequence_CS);

99.9995

C:\Users\502525009\Documents\SRIF_docs\SRIFDesignDocument.docx

Interlocking0_signalMap

D:\Non-functional Tests.docx

 if(connectionInformation->connectionInformation.SequenceNumber > message.Header.SequenceNumber)
        {
            //fail case
            ret = 0;
        }

message.Header.SequenceNumber

Dan,
The requirements are:
RIF_9.2_30
RIF_9.2_33 / SR-SRIF-064
RIF_9.2_34 / SR-SRIF-065
RIF_9.2_35 / SR-SRIF-066
RIF_9.2_36 / SR-SRIF-067
RIF_9.2_37 / SR-SRIF-068
RIF_9.2_38 / SR-SRIF-069
RIF_9.3_01
RIF_9.3_02
RIF_9.3_03
RIF_9.3_04
SR-SRIF-002 SR-SRIF-003
SR-SRIF-108
Those beginning RIF_9xxxx can be found in the attached word file. We will need compliance responses to these requirements - I think a lot of them can just be answered by pointing to the relevant software design and/or test document. I'd prefer the design doc to cover as many as possible as it reduces the need for additional testing.

The SR-SRIF-xxx ones are in the second tab of the attached spreadsheet (SSL Safety Reqs) - that is the current GE compliance list and as you can see the current compliance response implies we need to put some tests together.

Have a look and see what you think,
Mike

connectionInformation->connectionInformation.SequenceNumber

E:\IconisSim

