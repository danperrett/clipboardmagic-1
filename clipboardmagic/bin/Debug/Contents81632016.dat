C:\StarTeam\Products\Modular Control System\Software\Source Code\Generic - Current\0005 Archive and Analysis_bak\Configuration\config.vcxproj.filters

C:\StarTeam\Products\Modular Control System\Software\Source Code\Generic - Current\0005 Archive and Analysis_bak\Configuration\config.vcxproj.user

C:\StarTeam\Products\Modular Control System\Software\Source Code\Generic - Current\0005 Archive and Analysis_bak\Configuration\config.sln

C:\StarTeam\Products\Modular Control System\Software\Source Code\Generic - Current\0005 Archive and Analysis_bak\Configuration\config.vcxproj

C:\StarTeam\Products\Modular Control System\Software\Source Code\Generic - Current\0005 Archive and Analysis_bak\Configuration\res\RailEdge.ico

026399641

C:\StarTeam\48SA019 Win32 MCS Logger\Minutes and Reviews\48-019-A-0010- Design Review Record.doc

https://blogs.technet.microsoft.com/askds/2007/10/23/high-accuracy-w32time-requirements/

?Support boundary to configure the Windows Time service for high accuracy environments?

?We do not guarantee and we do not support the accuracy of the W32Time service between nodes on a network. The W32Time service is not a full-featured NTP solution that meets time-sensitive application needs. The W32Time service is primarily designed to do the following:

Make the Kerberos version 5 authentication protocol work. 
Provide loose sync time for client computers.
The W32Time service cannot reliably maintain sync time to the range of 1 to 2 seconds. Such tolerances are outside the design specification of the W32Time service.?

Alstom Transport UK Ltd

C:\StarTeam\48SA019 Win32 MCS Logger\Software\Source Code\Images

C:\StarTeam\48SA019 Win32 MCS Logger\Software\Source Code\Images\favicon.ico

C:\StarTeam\Products\Modular Control System\Software\Source Code\Generic - Current\0005 Archive and Analysis\res\icon1.ico

icon1

17/010/A/1723

Joseph O?Flaherty

17/010/A/1723

48-019-A-0010

48-019-A-0010 For Logger with LAN

memcpy(date, &timedate[DATE], 2);

enum
{
    YEAR = 0,
    MONTH = 5,
    DATE = 8,
    HOUR = 11,
    MIN = 14,
    SEC = 17
}DateMonthSeperation;
void extractDate(BYTE* timedate)
{
    char* date = "--/--/----\0";
    
    memcpy(date, &timedate[DATE], 2);
    memcpy(date, &timedate[MONTH], 2);
    memcpy(date, &timedate[YEAR], 4);
}

BYTE CheckifDigits(char* input, WORD length)

&timedate[DATE]

CHECKPARAMANDEXIT

CHECKPARAMANDEXIT(CheckifDigits((char *)&timedate[DATE], 2), 0, "Unreadable Date");

setupTime

extractDate

time_t->Current.value

LOGGER("Extract the date Stamp to force internal clock date to be the same", "", ALWAYS);

Microphone

/**
<pre>
FUNCTION:                                                        
  static void decodeTimeElement(XMLElement *time, Time_t *time_t)
                                                                 
DESCRIPTION:                                                     
  Called to decode the component subfields of a time element     
                                                                 
PARAMETERS:                                                      
  XMLElement *time       Input XML element                       
  Time_t *time_t         Data structure to contain received data 

RETURNS:
  void

</pre>
*/

extractDate

 PostMessageA(hWnd, WM_TIMESYNC, 1, 1);

day

CHECKPARAMANDEXIT(CheckifDigits((char *)&timedate[YEAR], 4), 0, "Unreadable Year");

HOUR

memcpy(year, &timedate[YEAR], 4);

CHECKPARAMANDEXIT(CheckifDigits((char *)&timedate[HOUR], 2), 0, "Unreadable Hour");
    memcpy(hour, &timedate[HOUR], 2);

CHECKPARAMANDEXIT(CheckifDigits((char *)&timedate[HOUR], 2), 0, "Unreadable Hour");
    memcpy(hour, &timedate[HOUR], 2);
    time.wHour = atoi(hour);

MIN

SEC

CHECKPARAMANDEXIT(CheckifDigits((char *)&timedate[MIN], 2), 0, "Unreadable Hour");
    memcpy(min, &timedate[MIN], 2);
    time.wMinute = atoi(min);

S:\MCS LAN WKS

C:\MCS LAN WKS\Workstation 3.0.2 Ayr Enhanced 2015-06-22\ws.cfg

$(ProjectDir)

C:\MCS LAN WKS\MCS_WKS test with lan and serial\Bin\DIO_TC.DLL

DWORD COMMS_Watchdog( DWORD thread )
{
    /*
    This is tolerable for Workstation since the limited number of communication
    ports means that there should donly ever be one comms thread, which in turn
    means that the thread parameter will be invariant.
    */
    GENPROJ_Thread_Status( COMMS_IN_THREAD |COMMS_OUT_THREAD );
    return THREAD_PAUSE_TIMER ;
}

  COMMS_Start( COMMS_FLAG_THREADED_APP ) ;

 COMMS_Start( COMMS_FLAG_THREADED_APP ) ;

NET_ParseChannelConfig

#include "arrays.h"
#include "buffers.h"
#include "common.h"
#include "files.h"
#include "queues.h"
#include "messages.h"
#include "comms_struct.h"

#include "comms_struct.h"

..\MACE_XP

comms_handle

Commsin_Thread

CONFIG_Validate_Primary_ID

WKSID_SIZE

wks_identity_list

void COMMS_OnError( comms_port_t *comport, DWORD error )
{
}

void COMMS_OnConnect( comms_port_t *comport  )
{
}

// central COMMS logging function
void COMMS_Log( const char* fmt, ... ) 
{
	va_list args;
	va_start (args, fmt);
	vfprintf (stdout, fmt, args);
	va_end (args);

	fputc( '\n', stdout ) ; 

}

// central error report  function
void COMMS_Error( const char* fmt, ... ) 
{
	va_list args;
	va_start (args, fmt);
	vfprintf (stderr, fmt, args);
	va_end (args);

	fputc( '\n', stdout ) ; 
}

#include <stdio.h>

void COMMS_OnError( comms_port_t *comport, DWORD error )
{
}

void COMMS_OnConnect( comms_port_t *comport  )
{
}

// central COMMS logging function
void COMMS_Log( const char* fmt, ... ) 
{
	va_list args;
	va_start (args, fmt);
	vfprintf (stdout, fmt, args);
	va_end (args);

	fputc( '\n', stdout ) ; 

}

// central error report  function
void COMMS_Error( const char* fmt, ... ) 
{
	va_list args;
	va_start (args, fmt);
	vfprintf (stderr, fmt, args);
	va_end (args);

	fputc( '\n', stdout ) ; 
}


COMMS_OnRxData

// ----------------------------------------------------------------------------
//
// FUNCTION:
//   GENCOMMS_Tchout
//
// DESCRIPTION:
//   Function to store output character in channel transmit buffer
//
// PARAMETERS:
//  int8  charcode - character for output
//  uint16 channel - output channel
//
//  Returns 0xFFFF if buffer full, else return 0 if OK
//
// LIMITATIONS:
//   None
//
// NOTES:
//
uint16 GENCOMMS_Tchout(int8 charcode,uint16 channel)
{
	return (TRUE == Project.iml.status.ce_comms)?COMMS_ChannelWriteChar( (comms_channel_t*)&Comms_Data[ channel], charcode, 0 ):0 ;
}

// Notify the application on the receipt of data.   Application may return FALSE to discard this data.
BOOL COMMS_OnRxData( comms_port_t* port, const unsigned char* ibuff_ptr, size_t ibuff_count,  DWORD comms_status ) 
{
	return TRUE ;
}

// Notify the application on the receipt of data.   Application may return FALSE to discard this data.
BOOL COMMS_OnRxData( comms_port_t* port, const unsigned char* ibuff_ptr, size_t ibuff_count,  DWORD comms_status ) 
{
	return TRUE ;
}

void COMMS_OnTxData( comms_port_t* port, const unsigned char* obuff_ptr, size_t obuff_count ) 
{
	int channel ;
	for( channel = 0 ; channel < _countof( Channel_Array ) ; ++channel )
	{
		if( &(Comms_Data[ channel ]) == (COMMS_STRUCT*)port->cp_channel )
		{
			// update last transmit time
			if (0 == (Channel_Array[channel].interrupt_timer = Time.cyclic10ms) )
			{
				Channel_Array[channel].interrupt_timer++;
			}
			break ;
		}
	}
}

Commsout_Thread

STARTUP_Create_Threads

C:\MCS LAN WKS\MCS_WKS test with lan and serial\ws.cfg

return COMMS_ChannelReadChar( (comms_channel_t*)&Comms_Data[ channel], 0 ) ;

	return (TRUE == Project.iml.status.ce_comms)?COMMS_ChannelWriteChar( (comms_channel_t*)&Comms_Data[ channel], charcode, 0 ):0 ;

BOOL COMMS_OnRxData( comms_port_t* port, const unsigned char* ibuff_ptr, size_t ibuff_count,  DWORD comms_status ) 
{
	return TRUE ;
}

void COMMS_OnTxData( comms_port_t* port, const unsigned char* obuff_ptr, size_t obuff_count ) 
{
	int channel ;
	for( channel = 0 ; channel < _countof( Channel_Array ) ; ++channel )
	{
		if( &(Comms_Data[ channel ]) == (COMMS_STRUCT*)port->cp_channel )
		{
			// update last transmit time
			if (0 == (Channel_Array[channel].interrupt_timer = Time.cyclic10ms) )
			{
				Channel_Array[channel].interrupt_timer++;
			}
			break ;
		}
	}
}

COMMS_InFlush

\\192.168.1.3\techterm\CHAN.X86

$(ProjectName)

$(SolutionDir)$(Configuration)\

$(ProjectDir)

C:\StarTeam\48SA009 Generic Tech Term\Software\Source Code\Debug\CHAN.X86

192.168.1.101

